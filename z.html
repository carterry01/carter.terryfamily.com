<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blob Eater Online</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #gameCanvas {
      background: #333;
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      box-shadow: 0 0 24px #000a;
      z-index: 1;
    }
    h1 {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      margin: 0;
      padding: 12px 0 0 0;
      font-size: 2.2em;
      z-index: 2;
      pointer-events: none;
      text-shadow: 0 2px 8px #000a;
    }
    #startScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(34,34,34,0.98);
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #startScreen input[type="text"] {
      font-size: 1.2em;
      padding: 8px 12px;
      border-radius: 5px;
      border: none;
      margin-bottom: 18px;
      outline: none;
      width: 220px;
      text-align: center;
      background: #444;
      color: #fff;
      box-shadow: 0 2px 8px #0006;
    }
    #startScreen button {
      font-size: 1.2em;
      padding: 8px 32px;
      border-radius: 5px;
      border: none;
      background: #4cf;
      color: #222;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 8px #0006;
      transition: background 0.2s;
    }
    #startScreen button:disabled {
      background: #888;
      color: #444;
      cursor: not-allowed;
    }
    #usernameLabel {
      font-size: 1.1em;
      margin-bottom: 8px;
      color: #fff;
      letter-spacing: 1px;
    }
    #usernameDisplay {
      position: absolute;
      top: 60px;
      left: 0;
      right: 0;
      z-index: 3;
      font-size: 1.1em;
      color: #fff;
      text-shadow: 0 2px 8px #000a;
      pointer-events: none;
      opacity: 0.85;
    }
    #connectionStatus {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      z-index: 20;
      color: #fa0;
      font-size: 1em;
      text-align: center;
      pointer-events: none;
      opacity: 0.8;
    }
  </style>
</head>
<body>
  <h1>Blob Eater Online</h1>
  <div id="startScreen">
    <div id="usernameLabel">Enter your username:</div>
    <input type="text" id="usernameInput" maxlength="16" autocomplete="off" placeholder="Your name..." />
    <button id="startBtn" disabled>Start</button>
  </div>
  <div id="usernameDisplay" style="display:none;"></div>
  <div id="connectionStatus" style="display:none;"></div>
  <canvas id="gameCanvas" style="display:none;"></canvas>
  <script>
    // --- Start Screen Logic ---
    const startScreen = document.getElementById('startScreen');
    const usernameInput = document.getElementById('usernameInput');
    const startBtn = document.getElementById('startBtn');
    const usernameDisplay = document.getElementById('usernameDisplay');
    const connectionStatus = document.getElementById('connectionStatus');
    const canvas = document.getElementById('gameCanvas');
    let username = "";

    // Networking
    let socket = null;
    let myId = null;
    let connected = false;
    let lastPing = 0;
    let lastServerState = null;

    // Enable start button only if username is not empty
    usernameInput.addEventListener('input', function() {
      startBtn.disabled = usernameInput.value.trim().length === 0;
    });

    // Allow pressing Enter to start
    usernameInput.addEventListener('keydown', function(e) {
      if (e.key === "Enter" && !startBtn.disabled) {
        startBtn.click();
      }
    });

    startBtn.addEventListener('click', function() {
      username = usernameInput.value.trim();
      if (username.length === 0) return;
      startScreen.style.display = "none";
      canvas.style.display = "block";
      usernameDisplay.textContent = "Player: " + username;
      usernameDisplay.style.display = "block";
      connectionStatus.style.display = "block";
      // Start the game loop
      startGame();
    });

    // --- Game Logic ---
    let ctx = canvas.getContext('2d');

    // Set canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // Camera follows the player blob, keeping it centered
    let camera = {
      x: 0,
      y: 0
    };

    // --- Jiggly Blob Helper (used for both player and food blobs) ---
    function randomColor() {
      const colors = ['#f44', '#fc4', '#4f4', '#4cf', '#c4f', '#fff', '#fa0', '#0fa'];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    // --- Networking: minimal protocol ---
    // We'll use a simple WebSocket protocol:
    // - On connect, client sends: {type:"join", username}
    // - On move, client sends: {type:"move", dx, dy}
    // - Server sends: {type:"state", you: {id, ...}, players: [...], blobs: [...]}
    // - Server sends: {type:"ping"} and expects {type:"pong"}

    // For demo: use a public echo server if no backend, but for real multiplayer, you need a Node.js server.
    // For this code, we'll use a simple local server if available, else fallback to wss://echo.websocket.org (which will not work for real game).
    // To run a real server, see the note at the end.

    // --- Game State ---
    let myBlob = null;
    let allPlayers = {};
    let foodBlobs = [];

    // Controls
    let moveDir = {dx: 0, dy: 0};
    function setupControls() {
      document.addEventListener('keydown', keydownHandler);
      document.addEventListener('keyup', keyupHandler);
    }
    function removeControls() {
      document.removeEventListener('keydown', keydownHandler);
      document.removeEventListener('keyup', keyupHandler);
    }
    function keydownHandler(e) {
      let changed = false;
      if (e.key === 'ArrowUp' || e.key === 'w') { if (moveDir.dy !== -1) changed = true; moveDir.dy = -1; }
      if (e.key === 'ArrowDown' || e.key === 's') { if (moveDir.dy !== 1) changed = true; moveDir.dy = 1; }
      if (e.key === 'ArrowLeft' || e.key === 'a') { if (moveDir.dx !== -1) changed = true; moveDir.dx = -1; }
      if (e.key === 'ArrowRight' || e.key === 'd') { if (moveDir.dx !== 1) changed = true; moveDir.dx = 1; }
      if (changed) sendMove();
    }
    function keyupHandler(e) {
      let changed = false;
      if (['ArrowUp','w','ArrowDown','s'].includes(e.key)) { moveDir.dy = 0; changed = true; }
      if (['ArrowLeft','a','ArrowRight','d'].includes(e.key)) { moveDir.dx = 0; changed = true; }
      if (changed) sendMove();
    }

    function sendMove() {
      if (socket && connected) {
        socket.send(JSON.stringify({type: "move", dx: moveDir.dx, dy: moveDir.dy}));
      }
    }

    // Camera follows myBlob
    function updateCamera() {
      if (myBlob) {
        camera.x = myBlob.x - canvas.width / 2;
        camera.y = myBlob.y - canvas.height / 2;
      }
    }

    // Draw a jiggly blob at world coordinates, using camera offset
    function drawJigglyBlob(b, time, showName) {
      const screenX = b.x - camera.x;
      const screenY = b.y - camera.y;
      // Only draw if on screen
      if (
        screenX + b.radius < 0 || screenX - b.radius > canvas.width ||
        screenY + b.radius < 0 || screenY - b.radius > canvas.height
      ) return;
      ctx.save();
      ctx.beginPath();
      for (let i = 0; i <= b.points; i++) {
        const t = i % b.points;
        const angle = (t / b.points) * Math.PI * 2;
        // Jiggly offset
        let jiggle = Math.sin(time * b.jiggleSpeed + b.phase + t) * b.jiggleAmp;
        // Squish effect (for player when eating)
        if (b.squish && b.isPlayer) {
          // Squish in the direction of last squish
          const squishAmount = b.squish * Math.cos(angle - (b.squishAngle || 0));
          jiggle += squishAmount;
        }
        const r = b.radius * b.baseOffsets[t] * (1 + jiggle);
        const px = screenX + Math.cos(angle) * r;
        const py = screenY + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();

      // Draw username above player blob
      if (showName && b.username) {
        ctx.save();
        ctx.font = "bold 1.1em Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 4;
        ctx.fillText(b.username, screenX, screenY - b.radius - 10);
        ctx.restore();
      }
    }

    // --- Networking ---
    function connectToServer() {
      // Try to connect to local server, else fallback to echo server (demo only)
      let wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.hostname + ":8081";
      if (location.hostname === "localhost" || location.hostname === "127.0.0.1") {
        wsUrl = "ws://localhost:8081";
      }
      // For demo, fallback to public echo server (will not work for real game)
      let fallback = false;
      let triedFallback = false;
      function tryConnect(url) {
        socket = new WebSocket(url);
        socket.onopen = function() {
          connected = true;
          connectionStatus.textContent = "Connected!";
          connectionStatus.style.color = "#0fa";
          // Send join
          socket.send(JSON.stringify({type: "join", username}));
        };
        socket.onclose = function() {
          connected = false;
          connectionStatus.textContent = "Disconnected from server.";
          connectionStatus.style.color = "#fa0";
          if (!triedFallback && !fallback) {
            triedFallback = true;
            tryConnect("wss://echo.websocket.org");
          }
        };
        socket.onerror = function() {
          connected = false;
          connectionStatus.textContent = "Connection error.";
          connectionStatus.style.color = "#fa0";
        };
        socket.onmessage = function(event) {
          let msg;
          try { msg = JSON.parse(event.data); } catch (e) { return; }
          if (msg.type === "state") {
            lastServerState = msg;
            myId = msg.you && msg.you.id;
            // Update allPlayers and foodBlobs
            allPlayers = {};
            for (let p of msg.players) {
              allPlayers[p.id] = p;
            }
            myBlob = msg.you;
            foodBlobs = msg.blobs;
          } else if (msg.type === "ping") {
            socket.send(JSON.stringify({type: "pong"}));
          }
        };
      }
      tryConnect(wsUrl);
    }

    // --- Main Loop ---
    function update() {
      // All state is from server, so nothing to update here
      updateCamera();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Optionally, draw a faint grid for orientation
      const gridSize = 200;
      ctx.save();
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 1;
      for (
        let gx = Math.floor(camera.x / gridSize) * gridSize;
        gx < camera.x + canvas.width;
        gx += gridSize
      ) {
        ctx.beginPath();
        ctx.moveTo(gx - camera.x, 0);
        ctx.lineTo(gx - camera.x, canvas.height);
        ctx.stroke();
      }
      for (
        let gy = Math.floor(camera.y / gridSize) * gridSize;
        gy < camera.y + canvas.height;
        gy += gridSize
      ) {
        ctx.beginPath();
        ctx.moveTo(0, gy - camera.y);
        ctx.lineTo(canvas.width, gy - camera.y);
        ctx.stroke();
      }
      ctx.restore();

      // Draw food blobs
      let now = performance.now() * 0.002;
      for (let b of foodBlobs) drawJigglyBlob(b, now, false);

      // Draw all players
      for (let id in allPlayers) {
        let p = allPlayers[id];
        drawJigglyBlob(p, now, true);
      }
    }

    let animationId = null;
    function loop() {
      update();
      draw();
      animationId = requestAnimationFrame(loop);
    }

    // On resize, keep the camera centered
    window.addEventListener('resize', () => {
      if (canvas.style.display !== "none") {
        resizeCanvas();
        updateCamera();
      }
    });

    // Start the game after username is entered and start button is pressed
    function startGame() {
      resizeCanvas();
      setupControls();
      connectToServer();
      loop();
    }

    // If user reloads, show start screen again and stop game loop
    function stopGame() {
      if (animationId) cancelAnimationFrame(animationId);
      removeControls();
      if (socket) {
        socket.close();
        socket = null;
      }
      canvas.style.display = "none";
      usernameDisplay.style.display = "none";
      connectionStatus.style.display = "none";
      startScreen.style.display = "flex";
      usernameInput.value = "";
      startBtn.disabled = true;
      username = "";
      myBlob = null;
      allPlayers = {};
      foodBlobs = [];
    }

    // Optional: allow restarting by pressing Escape
    document.addEventListener('keydown', function(e) {
      if (e.key === "Escape" && canvas.style.display !== "none") {
        stopGame();
      }
    });

    // On first load, show start screen, hide canvas
    stopGame();

    // --- Demo server note ---
    /*
    To make this work as a real online game, you need a Node.js WebSocket server.
    Example server (save as server.js and run with `node server.js`):

    const WebSocket = require('ws');
    const wss = new WebSocket.Server({ port: 8081 });
    let players = {};
    let blobs = [];
    function randomColor() {
      const colors = ['#f44', '#fc4', '#4f4', '#4cf', '#c4f', '#fff', '#fa0', '#0fa'];
      return colors[Math.floor(Math.random() * colors.length)];
    }
    function makeJigglyBlob(x, y) {
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * 600 + 200;
      const radius = Math.random() * 10 + 10;
      const color = randomColor();
      const points = 18 + Math.floor(Math.random() * 6);
      const baseOffsets = [];
      for (let i = 0; i < points; i++) baseOffsets.push(Math.random() * 0.18 + 0.92);
      const phase = Math.random() * Math.PI * 2;
      return {x: x + Math.cos(angle)*dist, y: y + Math.sin(angle)*dist, radius, color, points, baseOffsets, phase, jiggleSpeed: 2, jiggleAmp: 0.15};
    }
    function spawnBlobs(aroundX, aroundY, n) {
      let arr = [];
      for (let i = 0; i < n; i++) arr.push(makeJigglyBlob(aroundX, aroundY));
      return arr;
    }
    function sendState() {
      let state = {
        type: "state",
        players: Object.values(players),
        blobs
      };
      for (let id in players) {
        let you = players[id];
        let ws = you.ws;
        if (ws.readyState === 1) {
          ws.send(JSON.stringify({...state, you}));
        }
      }
    }
    setInterval(sendState, 50);
    wss.on('connection', function connection(ws) {
      let id = Math.random().toString(36).substr(2, 9);
      let player = {
        id,
        username: "Player",
        x: 0, y: 0,
        radius: 24,
        color: "#4cf",
        points: 22,
        baseOffsets: Array.from({length:22},()=>Math.random()*0.18+0.92),
        phase: Math.random()*Math.PI*2,
        jiggleSpeed: 2.2,
        jiggleAmp: 0.16,
        isPlayer: true,
        squish: 0,
        squishDecay: 0.8,
        ws
      };
      players[id] = player;
      if (blobs.length < 14) blobs = blobs.concat(spawnBlobs(0,0,14-blobs.length));
      ws.on('message', function incoming(message) {
        let msg;
        try { msg = JSON.parse(message); } catch(e) { return; }
        if (msg.type === "join") {
          player.username = msg.username;
        }
        if (msg.type === "move") {
          let speed = 3;
          player.x += (msg.dx||0)*speed;
          player.y += (msg.dy||0)*speed;
          // Eat blobs
          for (let i = blobs.length-1; i>=0; i--) {
            let b = blobs[i];
            let dx = player.x - b.x, dy = player.y - b.y;
            let dist = Math.hypot(dx,dy);
            if (dist < player.radius + b.radius * 0.65) {
              player.radius += Math.max(2, b.radius*0.3);
              blobs.splice(i,1);
              blobs.push(makeJigglyBlob(player.x, player.y));
            }
          }
        }
        if (msg.type === "pong") { /* ignore */ 
      ;
      ws.on('close', function() {
        delete players[id];
      });
    ;
    

  </script>
</body>
</html>
