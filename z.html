<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Blob Eater (Offline)</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      background: #222;
      color: #fff;
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    #gameCanvas {
      background: #333;
      display: block;
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      box-shadow: 0 0 24px #000a;
      z-index: 1;
    }
    h1 {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      margin: 0;
      padding: 12px 0 0 0;
      font-size: 2.2em;
      z-index: 2;
      pointer-events: none;
      text-shadow: 0 2px 8px #000a;
    }
    #startScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(34,34,34,0.98);
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #startScreen input[type="text"] {
      font-size: 1.2em;
      padding: 8px 12px;
      border-radius: 5px;
      border: none;
      margin-bottom: 18px;
      outline: none;
      width: 220px;
      text-align: center;
      background: #444;
      color: #fff;
      box-shadow: 0 2px 8px #0006;
    }
    #startScreen button {
      font-size: 1.2em;
      padding: 8px 32px;
      border-radius: 5px;
      border: none;
      background: #4cf;
      color: #222;
      cursor: pointer;
      font-weight: bold;
      box-shadow: 0 2px 8px #0006;
      transition: background 0.2s;
    }
    #startScreen button:disabled {
      background: #888;
      color: #444;
      cursor: not-allowed;
    }
    #usernameLabel {
      font-size: 1.1em;
      margin-bottom: 8px;
      color: #fff;
      letter-spacing: 1px;
    }
    #usernameDisplay {
      position: absolute;
      top: 60px;
      left: 0;
      right: 0;
      z-index: 3;
      font-size: 1.1em;
      color: #fff;
      text-shadow: 0 2px 8px #000a;
      pointer-events: none;
      opacity: 0.85;
    }
    #offlineNotice {
      position: absolute;
      bottom: 16px;
      left: 0;
      right: 0;
      color: #aaa;
      font-size: 1em;
      z-index: 20;
      text-align: center;
      pointer-events: none;
      opacity: 0.7;
      letter-spacing: 1px;
    }
  </style>
</head>
<body>
  <h1>Blob Eater</h1>
  <div id="startScreen">
    <div id="usernameLabel">Enter your name:</div>
    <input type="text" id="usernameInput" maxlength="16" autocomplete="off" placeholder="Your name..." />
    <button id="startBtn" disabled>Start</button>
    <div id="offlineNotice">(Offline Mode: No network required. All play is local.)</div>
  </div>
  <div id="usernameDisplay" style="display:none;"></div>
  <canvas id="gameCanvas" style="display:none;"></canvas>
  <script>
    // --- Start Screen Logic (Offline/Local Only) ---
    const startScreen = document.getElementById('startScreen');
    const usernameInput = document.getElementById('usernameInput');
    const startBtn = document.getElementById('startBtn');
    const usernameDisplay = document.getElementById('usernameDisplay');
    const canvas = document.getElementById('gameCanvas');
    let username = "";

    // Enable start button only if username is not empty
    usernameInput.addEventListener('input', function() {
      startBtn.disabled = usernameInput.value.trim().length === 0;
    });

    // Allow pressing Enter to start
    usernameInput.addEventListener('keydown', function(e) {
      if (e.key === "Enter" && !startBtn.disabled) {
        startBtn.click();
      }
    });

    startBtn.addEventListener('click', function() {
      username = usernameInput.value.trim();
      if (username.length === 0) return;
      startScreen.style.display = "none";
      canvas.style.display = "block";
      usernameDisplay.textContent = "Player: " + username;
      usernameDisplay.style.display = "block";
      // Start the game loop
      startGame();
    });

    // --- Game Logic (All Local/Offline) ---
    let ctx = canvas.getContext('2d');

    // Set canvas to full window size
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    // Infinite world parameters
    // The world is conceptually infinite, but we only render what's visible
    // The camera follows the player blob
    let camera = {
      x: 0, // top-left world x of the viewport
      y: 0  // top-left world y of the viewport
    };

    // --- Jiggly Blob Helper (used for both player and food blobs) ---
    function randomColor() {
      const colors = ['#f44', '#fc4', '#4f4', '#4cf', '#c4f', '#fff', '#fa0', '#0fa'];
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function makeJigglyBlob(aroundX = 0, aroundY = 0, minDist = 200, maxDist = 800, opts = {}) {
      // Place at a random angle and distance from (aroundX, aroundY)
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * (maxDist - minDist) + minDist;
      const radius = opts.radius !== undefined ? opts.radius : (Math.random() * 10 + 10);
      const color = opts.color || randomColor();
      // Jiggly parameters
      const points = opts.points || (18 + Math.floor(Math.random() * 6)); // 18-23 points
      const baseOffsets = [];
      for (let i = 0; i < points; i++) {
        baseOffsets.push(Math.random() * 0.18 + 0.92); // 0.92-1.1
      }
      const phase = Math.random() * Math.PI * 2;
      return {
        x: opts.x !== undefined ? opts.x : (aroundX + Math.cos(angle) * dist),
        y: opts.y !== undefined ? opts.y : (aroundY + Math.sin(angle) * dist),
        radius,
        color,
        points,
        baseOffsets,
        phase,
        jiggleSpeed: opts.jiggleSpeed || (1.5 + Math.random() * 1.5),
        jiggleAmp: opts.jiggleAmp || (0.13 + Math.random() * 0.09),
        vx: 0,
        vy: 0,
        isPlayer: !!opts.isPlayer,
        squish: 0, // for squish effect when eating
        squishDecay: opts.squishDecay || 0.85
      };
    }

    // --- Player blob (jiggly) ---
    let blob = makeJigglyBlob(0, 0, 0, 0, {
      radius: 24,
      color: '#4cf',
      points: 22,
      jiggleSpeed: 2.2,
      jiggleAmp: 0.16,
      isPlayer: true,
      squishDecay: 0.8
    });
    blob.speed = 3;
    blob.dx = 0;
    blob.dy = 0;

    // Blobs to eat (each has world coordinates)
    let blobs = [];
    function resetBlobs() {
      blobs = [];
      for (let i = 0; i < 14; i++) blobs.push(makeJigglyBlob(blob.x, blob.y, 200, 800));
    }

    // Controls
    function setupControls() {
      document.addEventListener('keydown', keydownHandler);
      document.addEventListener('keyup', keyupHandler);
    }
    function removeControls() {
      document.removeEventListener('keydown', keydownHandler);
      document.removeEventListener('keyup', keyupHandler);
    }
    function keydownHandler(e) {
      if (e.key === 'ArrowUp' || e.key === 'w') blob.dy = -blob.speed;
      if (e.key === 'ArrowDown' || e.key === 's') blob.dy = blob.speed;
      if (e.key === 'ArrowLeft' || e.key === 'a') blob.dx = -blob.speed;
      if (e.key === 'ArrowRight' || e.key === 'd') blob.dx = blob.speed;
    }
    function keyupHandler(e) {
      if (['ArrowUp','w','ArrowDown','s'].includes(e.key)) blob.dy = 0;
      if (['ArrowLeft','a','ArrowRight','d'].includes(e.key)) blob.dx = 0;
    }

    // Camera follows the blob, keeping it centered
    function updateCamera() {
      camera.x = blob.x - canvas.width / 2;
      camera.y = blob.y - canvas.height / 2;
    }

    // Draw a jiggly blob at world coordinates, using camera offset
    function drawJigglyBlob(b, time) {
      const screenX = b.x - camera.x;
      const screenY = b.y - camera.y;
      // Only draw if on screen
      if (
        screenX + b.radius < 0 || screenX - b.radius > canvas.width ||
        screenY + b.radius < 0 || screenY - b.radius > canvas.height
      ) return;
      ctx.save();
      ctx.beginPath();
      for (let i = 0; i <= b.points; i++) {
        const t = i % b.points;
        const angle = (t / b.points) * Math.PI * 2;
        // Jiggly offset
        let jiggle = Math.sin(time * b.jiggleSpeed + b.phase + t) * b.jiggleAmp;
        // Squish effect (for player when eating)
        if (b.squish && b.isPlayer) {
          // Squish in the direction of last squish
          const squishAmount = b.squish * Math.cos(angle - b.squishAngle);
          jiggle += squishAmount;
        }
        const r = b.radius * b.baseOffsets[t] * (1 + jiggle);
        const px = screenX + Math.cos(angle) * r;
        const py = screenY + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = b.color;
      ctx.shadowColor = b.color;
      ctx.shadowBlur = 10;
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Helper: spawn a new blob not too close to the player
    function spawnBlobFarFromPlayer() {
      let newBlob;
      let tries = 0;
      do {
        newBlob = makeJigglyBlob(blob.x, blob.y, 400, 1200);
        tries++;
      } while (
        Math.hypot(newBlob.x - blob.x, newBlob.y - blob.y) < blob.radius + 80 && tries < 10
      );
      return newBlob;
    }

    // --- Blobs push in to you when you go on them, then eat ---
    function update() {
      // Move blob
      blob.x += blob.dx;
      blob.y += blob.dy;

      // Blobs push the player if overlapping, then get eaten if close enough
      for (let i = blobs.length - 1; i >= 0; i--) {
        let b = blobs[i];
        // Blob velocity decay (for smooth push)
        b.vx *= 0.92;
        b.vy *= 0.92;

        // Push logic
        let dx = blob.x - b.x;
        let dy = blob.y - b.y;
        let dist = Math.hypot(dx, dy);
        let minDist = blob.radius + b.radius * 0.85;
        if (dist < minDist) {
          // Push the player away from the blob center
          let overlap = minDist - dist;
          if (dist !== 0) {
            let pushX = (dx / dist) * overlap * 0.5;
            let pushY = (dy / dist) * overlap * 0.5;
            blob.x += pushX;
            blob.y += pushY;
            // Also, blob gets a little "squish" velocity away from player
            b.vx -= pushX * 0.2;
            b.vy -= pushY * 0.2;
            // Player gets squish effect in direction of push
            blob.squish = Math.min(blob.squish + overlap * 0.012, 0.18);
            blob.squishAngle = Math.atan2(dy, dx) + Math.PI; // squish away from food
          }
        }
        // Eat if very close (smaller threshold)
        if (dist < blob.radius + b.radius * 0.65) {
          // Eat!
          blob.radius += Math.max(2, b.radius * 0.3); // Get bigger
          // Player gets a big squish in direction of food
          blob.squish = 0.22;
          blob.squishAngle = Math.atan2(dy, dx) + Math.PI;
          blobs.splice(i, 1);
          // New blob somewhere far from player
          blobs.push(spawnBlobFarFromPlayer());
        }
      }

      // Move blobs by their velocity (for squish effect)
      for (let b of blobs) {
        b.x += b.vx || 0;
        b.y += b.vy || 0;
      }

      // Keep enough blobs in the world (in case player moves far)
      while (blobs.length < 14) {
        blobs.push(spawnBlobFarFromPlayer());
      }

      // Decay player squish
      if (blob.squish) {
        blob.squish *= blob.squishDecay;
        if (blob.squish < 0.01) blob.squish = 0;
      }

      updateCamera();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Optionally, draw a faint grid for orientation
      const gridSize = 200;
      ctx.save();
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 1;
      for (
        let gx = Math.floor(camera.x / gridSize) * gridSize;
        gx < camera.x + canvas.width;
        gx += gridSize
      ) {
        ctx.beginPath();
        ctx.moveTo(gx - camera.x, 0);
        ctx.lineTo(gx - camera.x, canvas.height);
        ctx.stroke();
      }
      for (
        let gy = Math.floor(camera.y / gridSize) * gridSize;
        gy < camera.y + canvas.height;
        gy += gridSize
      ) {
        ctx.beginPath();
        ctx.moveTo(0, gy - camera.y);
        ctx.lineTo(canvas.width, gy - camera.y);
        ctx.stroke();
      }
      ctx.restore();

      // Draw blobs to eat (jiggly)
      let now = performance.now() * 0.002;
      for (let b of blobs) drawJigglyBlob(b, now);
      // Draw player blob (jiggly)
      drawJigglyBlob(blob, now);

      // Draw username above player blob
      if (username && typeof blob.x === "number" && typeof blob.y === "number") {
        const screenX = blob.x - camera.x;
        const screenY = blob.y - camera.y;
        ctx.save();
        ctx.font = "bold 1.1em Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.fillStyle = "#fff";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 4;
        ctx.fillText(username, screenX, screenY - blob.radius - 10);
        ctx.restore();
      }
    }

    let animationId = null;
    function loop() {
      update();
      draw();
      animationId = requestAnimationFrame(loop);
    }

    // On resize, nothing to do except keep the camera centered
    window.addEventListener('resize', () => {
      if (canvas.style.display !== "none") {
        resizeCanvas();
        updateCamera();
      }
    });

    // Start the game after username is entered and start button is pressed
    function startGame() {
      // Show canvas, hide start screen
      resizeCanvas();
      // Reset player blob as jiggly
      blob = makeJigglyBlob(0, 0, 0, 0, {
        radius: 24,
        color: '#4cf',
        points: 22,
        jiggleSpeed: 2.2,
        jiggleAmp: 0.16,
        isPlayer: true,
        squishDecay: 0.8
      });
      blob.speed = 3;
      blob.dx = 0;
      blob.dy = 0;
      resetBlobs();
      updateCamera();
      setupControls();
      loop();
    }

    // If user reloads, show start screen again and stop game loop
    function stopGame() {
      if (animationId) cancelAnimationFrame(animationId);
      removeControls();
      canvas.style.display = "none";
      usernameDisplay.style.display = "none";
      startScreen.style.display = "flex";
      usernameInput.value = "";
      startBtn.disabled = true;
      username = "";
    }

    // Optional: allow restarting by pressing Escape
    document.addEventListener('keydown', function(e) {
      if (e.key === "Escape" && canvas.style.display !== "none") {
        stopGame();
      }
    });

    // On first load, show start screen, hide canvas
    stopGame();
  </script>
</body>
</html>
