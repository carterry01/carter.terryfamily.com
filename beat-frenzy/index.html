<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-CRRP42F4Z4"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-CRRP42F4Z4");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beat Frenzy</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --lane-green: #22c55e;
        --lane-red: #ef4444;
        --lane-yellow: #eab308;
        --lane-blue: #3b82f6;
        --lane-orange: #f97316;
        --bg-dark: #0a0a0f;
        --bg-panel: #12121a;
        --accent: #a855f7;
        --accent-glow: rgba(168, 85, 247, 0.4);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000; /* Black letterbox background */
        font-family: "Rajdhani", sans-serif;
        color: #fff;
      }

      /* App scaler - handles fixed resolution scaling */
      #appScaler {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 1600px;
        height: 900px;
        transform-origin: center center;
        /* transform: translate(-50%, -50%) scale() applied by JS */
        overflow: hidden;
      }

      #app {
        display: flex;
        width: 1600px;
        height: 900px;
        background: transparent;
        overflow: hidden;
      }

      /* Game Area */
      #gameArea {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: transparent;
        z-index: 1;
      }

      /* Game canvas container - now just fills the game area */
      #gameScaler {
        width: 100%;
        height: 100%;
        position: relative;
      }

      /* Video Background */
      #videoContainer {
        position: absolute;
        top: 0;
        left: 0;
        width: 1600px;
        height: 900px;
        z-index: 0;
        overflow: hidden;
        opacity: 0;
        transition: opacity 0.8s ease;
        pointer-events: none;
        border-radius: 0;
      }

      #videoContainer.active {
        opacity: 1;
      }

      #backgroundVideo,
      #backgroundImage {
        position: absolute;
        top: 50%;
        left: 50%;
        min-width: 100%;
        min-height: 100%;
        width: auto;
        height: auto;
        transform: translate(-50%, -50%) scale(1.1);
        object-fit: cover;
        filter: blur(2px) saturate(1.3) brightness(0.6);
        transition: filter 0.3s ease, opacity 0.3s ease;
      }

      #backgroundImage {
        display: none;
        z-index: 0;
      }

      #backgroundImage.active {
        display: block;
      }

      #backgroundVideo {
        z-index: 1;
      }

      #videoContainer.active #backgroundVideo,
      #videoContainer.active #backgroundImage.active {
        animation: videoFloat 20s ease-in-out infinite;
      }

      @keyframes videoFloat {
        0%,
        100% {
          transform: translate(-50%, -50%) scale(1.1);
        }
        50% {
          transform: translate(-50%, -50%) scale(1.15);
        }
      }

      /* Video Overlay Effects */
      #videoOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        background: radial-gradient(
            ellipse at center,
            transparent 0%,
            rgba(10, 10, 15, 0.4) 60%,
            rgba(10, 10, 15, 0.95) 100%
          ),
          linear-gradient(
            180deg,
            rgba(10, 10, 15, 0.3) 0%,
            transparent 30%,
            transparent 70%,
            rgba(10, 10, 15, 0.5) 100%
          );
      }

      /* Scanline effect for retro feel */
      #videoOverlay::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.1) 2px,
          rgba(0, 0, 0, 0.1) 4px
        );
        pointer-events: none;
        opacity: 0.5;
      }

      /* Video glow pulse on beat */
      #videoGlow {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        box-shadow: inset 0 0 100px rgba(168, 85, 247, 0);
        transition: box-shadow 0.1s ease;
        z-index: 3;
      }

      /* On Fire (combo 25+): Blue */
      #videoGlow.glow-fire.pulse {
        box-shadow: inset 0 0 25px rgba(96, 165, 250, 0.3);
      }

      /* Blazing (combo 50+): Purple */
      #videoGlow.glow-blazing.pulse {
        box-shadow: inset 0 0 50px rgba(168, 85, 247, 0.3);
      }

      /* Unstoppable (combo 75+): Green */
      #videoGlow.glow-unstoppable.pulse {
        box-shadow: inset 0 0 75px rgba(74, 222, 128, 0.3);
      }

      /* Legendary (combo 100+): Orange */
      #videoGlow.glow-legendary.pulse {
        box-shadow: inset 0 0 100px rgba(251, 146, 60, 0.3);
      }

      /* Godlike (combo 150+): Gold */
      #videoGlow.glow-godlike.pulse {
        box-shadow: inset 0 0 150px rgba(255, 215, 0, 0.3);
      }

      /* Perfection (combo 200+): White */
      #videoGlow.glow-perfection.pulse {
        box-shadow: inset 0 0 300px rgba(255, 255, 255, 0.4);
      }

      /* Video badge indicator */
      .video-badge {
        display: inline-block;
        background: linear-gradient(135deg, #ec4899, #a855f7);
        color: white;
        font-size: 0.6em;
        padding: 2px 6px;
        border-radius: 4px;
        margin-left: 6px;
        vertical-align: middle;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 8px rgba(168, 85, 247, 0.4);
      }

      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
        z-index: 1;
      }

      /* Sidebar */
      #sidebar {
        width: 380px;
        flex-shrink: 0;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        background: rgba(0, 0, 0, 0.4);
        border-left: 1px solid rgba(168, 85, 247, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
        z-index: 10;
      }

      #logo {
        padding: 24px;
        text-align: center;
        background: linear-gradient(
          135deg,
          rgba(168, 85, 247, 0.15),
          transparent
        );
        border-bottom: 1px solid rgba(168, 85, 247, 0.2);
      }

      #logo h1 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.8em;
        font-weight: 900;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: 0 0 30px var(--accent-glow);
        letter-spacing: 3px;
      }

      #logo p {
        font-size: 0.85em;
        color: #888;
        margin-top: 4px;
      }

      /* Search Box */
      #searchContainer {
        display: flex;
        flex-direction: column;
        padding: 10px 12px;
        border-bottom: 1px solid rgba(168, 85, 247, 0.15);
      }

      #searchRow {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      #searchWrapper {
        position: relative;
        flex: 1;
      }

      #searchInput {
        width: 100%;
        padding: 8px 32px 8px 32px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        color: #fff;
        font-family: "Rajdhani", sans-serif;
        font-size: 0.9em;
        outline: none;
        transition: all 0.2s ease;
      }

      #searchInput::placeholder {
        color: #666;
      }

      #searchInput:focus {
        background: rgba(168, 85, 247, 0.1);
        border-color: rgba(168, 85, 247, 0.4);
        box-shadow: 0 0 12px rgba(168, 85, 247, 0.15);
      }

      #searchWrapper::before {
        content: "üîç";
        position: absolute;
        left: 10px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 0.8em;
        opacity: 0.5;
        pointer-events: none;
      }

      #clearSearch {
        position: absolute;
        right: 6px;
        top: 50%;
        transform: translateY(-50%);
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 1em;
        padding: 2px 6px;
        border-radius: 4px;
        display: none;
        transition: color 0.2s ease;
      }

      #clearSearch:hover {
        color: #fff;
      }

      #clearSearch.visible {
        display: block;
      }

      #openFolderBtn {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        padding: 0;
        background: linear-gradient(135deg, var(--accent), #7c3aed);
        border: none;
        border-radius: 8px;
        color: #fff;
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 2px 10px rgba(168, 85, 247, 0.3);
        flex-shrink: 0;
      }

      #openFolderBtn:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 15px rgba(168, 85, 247, 0.5);
      }

      #openFolderBtn:active {
        transform: translateY(0);
      }

      #filterRow {
        display: flex;
        gap: 6px;
        margin-top: 8px;
      }

      #filterRow select {
        flex: 1;
        min-width: 0;
        padding: 6px 8px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        color: #ccc;
        font-family: "Rajdhani", sans-serif;
        font-size: 0.8em;
        cursor: pointer;
        outline: none;
        transition: all 0.2s ease;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
      }

      #filterRow select:hover {
        background: rgba(168, 85, 247, 0.1);
        border-color: rgba(168, 85, 247, 0.3);
      }

      #filterRow select:focus {
        border-color: rgba(168, 85, 247, 0.5);
      }

      #filterRow select option {
        background: #1a1a2e;
        color: #ccc;
      }

      #videoFilterLabel {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
        flex: 1;
        min-width: 0;
        cursor: pointer;
        font-size: 0.8em;
        color: #ccc;
        padding: 5px 10px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 6px;
        transition: all 0.2s ease;
        user-select: none;
      }

      #videoFilterLabel:hover {
        background: rgba(168, 85, 247, 0.1);
        border-color: rgba(168, 85, 247, 0.3);
      }

      #videoFilterLabel:has(#videoFilter:checked) {
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.2),
          rgba(168, 85, 247, 0.2)
        );
        border-color: rgba(168, 85, 247, 0.5);
        color: #fff;
      }

      #videoFilter {
        display: none;
      }

      #videoFilterLabel .checkbox-icon {
        font-size: 1em;
      }

      #videoFilterLabel .checkbox-icon::before {
        content: "‚òê";
      }

      #videoFilterLabel:has(#videoFilter:checked) .checkbox-icon::before {
        content: "‚òë";
      }

      #clearFilters {
        margin-top: 8px;
        margin-left: auto;
        padding: 5px 10px;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 6px;
        color: #ef4444;
        font-family: "Rajdhani", sans-serif;
        font-size: 0.75em;
        cursor: pointer;
        transition: all 0.2s ease;
        display: none;
      }

      #clearFilters.visible {
        display: block;
      }

      #clearFilters:hover {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.5);
      }

      #songCount {
        font-size: 0.7em;
        color: #666;
        margin-top: 4px;
        text-align: center;
      }

      /* Song List */
      #songList {
        flex: 1;
        overflow-y: auto;
        overflow-x: hidden;
        padding: 16px;
      }

      #songList::-webkit-scrollbar {
        width: 6px;
      }

      #songList::-webkit-scrollbar-track {
        background: transparent;
      }

      #songList::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }

      .song-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        margin-bottom: 8px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .song-item:hover {
        background: rgba(168, 85, 247, 0.1);
        border-color: rgba(168, 85, 247, 0.3);
        transform: translateX(4px);
      }

      .song-item.selected {
        background: rgba(168, 85, 247, 0.2);
        border-color: var(--accent);
      }

      .song-item img {
        width: 48px;
        height: 48px;
        border-radius: 4px;
        object-fit: cover;
        background: #333;
      }

      .song-info {
        flex: 1;
        min-width: 0;
      }

      .song-title {
        font-weight: 700;
        font-size: 1em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .song-artist {
        font-size: 0.85em;
        color: #888;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .song-meta {
        display: flex;
        align-items: center;
        flex-shrink: 0;
        gap: 10px;
        font-size: 0.8em;
        color: #666;
      }

      .song-duration {
        font-variant-numeric: tabular-nums;
        color: #888;
      }

      .song-difficulty {
        display: flex;
        gap: 2px;
      }

      .song-difficulty .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #333;
        transition: background 0.2s;
      }

      .song-difficulty .dot.filled {
        background: var(--accent);
      }

      .song-difficulty .dot.filled-1 {
        background: #22c55e;
      }
      .song-difficulty .dot.filled-2 {
        background: #84cc16;
      }
      .song-difficulty .dot.filled-3 {
        background: #eab308;
      }
      .song-difficulty .dot.filled-4 {
        background: #f97316;
      }
      .song-difficulty .dot.filled-5 {
        background: #ef4444;
      }
      .song-difficulty .dot.filled-6 {
        background: #dc2626;
      }

      .song-item[data-loading-phrase] {
        position: relative;
      }

      .song-item[data-loading-phrase]::after {
        content: attr(data-loading-phrase);
        position: absolute;
        left: 60px;
        right: 10px;
        bottom: calc(100% + 8px);
        background: rgba(0, 0, 0, 0.95);
        border: 1px solid rgba(168, 85, 247, 0.4);
        color: #ccc;
        padding: 10px 12px;
        border-radius: 8px;
        font-size: 0.85em;
        line-height: 1.4;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
        z-index: 100;
        pointer-events: none;
        max-width: 350px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      }

      /* Now Playing */
      #nowPlaying {
        background: rgba(0, 0, 0, 0.4);
        border-top: 1px solid rgba(168, 85, 247, 0.2);
        transition: all 0.3s ease;
      }

      #nowPlayingHeader {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 10px 16px;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s ease;
      }

      #nowPlayingHeader:hover {
        background: rgba(168, 85, 247, 0.1);
      }

      #nowPlaying h3 {
        font-size: 0.8em;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--accent);
        margin: 0;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .collapse-icon {
        font-size: 1.2em;
        transition: transform 0.3s ease;
      }

      #nowPlaying.collapsed .collapse-icon {
        transform: rotate(180deg);
      }

      #nowPlayingContent {
        padding: 0 16px 12px;
        transition: all 0.3s ease;
        overflow: hidden;
      }

      #nowPlaying.collapsed #nowPlayingContent {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
      }

      /* Mini player shown when collapsed */
      #miniPlayer {
        display: none;
        align-items: center;
        gap: 10px;
        padding: 0 16px 12px;
      }

      #nowPlaying.collapsed #miniPlayer {
        display: flex;
      }

      #miniPlayer img {
        width: 40px;
        height: 40px;
        border-radius: 6px;
        object-fit: cover;
        border: 1px solid rgba(168, 85, 247, 0.3);
      }

      #miniPlayer .mini-info {
        flex: 1;
        min-width: 0;
      }

      #miniPlayer .mini-title {
        font-family: "Orbitron", sans-serif;
        font-size: 0.9em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #miniPlayer .mini-artist {
        font-size: 0.8em;
        color: #888;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #miniPlayer .mini-play-btn {
        width: 38px;
        height: 38px;
        border-radius: 50%;
        border: none;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        color: white;
        font-size: 1.1em;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        flex-shrink: 0;
      }

      #miniPlayer .mini-play-btn:hover:not(:disabled) {
        transform: scale(1.1);
        box-shadow: 0 4px 15px var(--accent-glow);
      }

      #miniPlayer .mini-play-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #miniPlayer .mini-play-btn.playing {
        background: linear-gradient(135deg, #22c55e, #16a34a);
      }

      #miniPlayer .mini-play-btn.paused {
        background: linear-gradient(135deg, #eab308, #ca8a04);
      }

      /* Hide entire section when no song selected */
      #nowPlaying.no-song {
        display: none;
      }

      #albumArt {
        width: 100%;
        aspect-ratio: 1;
        border-radius: 8px;
        background: #222;
        margin-bottom: 12px;
        object-fit: cover;
        border: 2px solid rgba(168, 85, 247, 0.3);
      }

      #songInfoRow {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        margin-bottom: 10px;
      }

      #nowPlayingContent #albumArt {
        width: 80px;
        height: 80px;
        object-fit: cover;
        display: block;
        border-radius: 6px;
      }

      #albumArtContainer {
        position: relative;
        flex-shrink: 0;
        width: 80px;
        height: 80px;
      }

      #songDetails {
        flex: 1;
        min-width: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }

      #videoIndicator {
        position: absolute;
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(
          135deg,
          rgba(236, 72, 153, 0.9),
          rgba(168, 85, 247, 0.9)
        );
        color: white;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.6em;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: none;
        align-items: center;
        gap: 4px;
        box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
        backdrop-filter: blur(4px);
        animation: videoIndicatorPulse 2s ease-in-out infinite;
      }

      #videoIndicator.active {
        display: flex;
      }

      @keyframes videoIndicatorPulse {
        0%,
        100% {
          box-shadow: 0 2px 10px rgba(168, 85, 247, 0.5);
          transform: translateX(-50%) scale(1);
        }
        50% {
          box-shadow: 0 2px 15px rgba(168, 85, 247, 0.7);
          transform: translateX(-50%) scale(1.02);
        }
      }

      #videoIndicator .icon {
        font-size: 0.9em;
      }

      #currentSong {
        font-family: "Orbitron", sans-serif;
        font-size: 0.85em;
        margin-bottom: 2px;
        text-align: left;
        line-height: 1.3;
        overflow: hidden;
        text-overflow: ellipsis;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      #currentArtist {
        color: #888;
        margin-bottom: 4px;
        text-align: left;
        font-size: 0.8em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      #songMeta {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        gap: 4px 8px;
        font-size: 0.7em;
        color: #666;
        margin-bottom: 4px;
      }

      #songMeta span:empty {
        display: none;
      }

      #songMeta span:not(:empty) + span:not(:empty)::before {
        content: "‚Ä¢";
        margin-right: 8px;
        color: #444;
      }

      #loadingPhrase {
        font-size: 0.7em;
        color: #999;
        text-align: left;
        font-style: italic;
        margin-bottom: 0;
        line-height: 1.3;
        max-height: 2.6em;
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }

      #loadingPhrase:empty {
        display: none;
      }

      /* Instrument Selection */
      #instrumentSelect {
        display: flex;
        gap: 6px;
        margin-bottom: 10px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .instrument-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        padding: 6px 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: #aaa;
        border-radius: 6px;
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
        font-size: 0.7em;
        cursor: pointer;
        transition: all 0.2s ease;
        min-width: 50px;
      }

      .instrument-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      .instrument-btn.selected {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .instrument-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .instrument-btn .icon {
        font-size: 1.3em;
      }

      .instrument-btn .diff-badge {
        display: flex;
        gap: 2px;
        margin-top: 2px;
      }

      .instrument-btn .diff-badge .dot {
        width: 5px;
        height: 5px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.2);
      }

      .instrument-btn .diff-badge .dot.filled {
        background: var(--accent);
      }

      .instrument-btn .diff-badge .dot.filled-1 {
        background: #22c55e;
      }
      .instrument-btn .diff-badge .dot.filled-2 {
        background: #84cc16;
      }
      .instrument-btn .diff-badge .dot.filled-3 {
        background: #eab308;
      }
      .instrument-btn .diff-badge .dot.filled-4 {
        background: #f97316;
      }
      .instrument-btn .diff-badge .dot.filled-5 {
        background: #ef4444;
      }
      .instrument-btn .diff-badge .dot.filled-6 {
        background: #dc2626;
      }

      /* Lane Count Selection */
      #laneCountSelect {
        display: flex;
        gap: 4px;
        margin-bottom: 10px;
        justify-content: center;
      }

      .lane-btn {
        width: 30px;
        height: 30px;
        border: 2px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: #aaa;
        border-radius: 50%;
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        font-size: 0.85em;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .lane-btn:hover {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border-color: rgba(255, 255, 255, 0.4);
      }

      .lane-btn.selected {
        background: linear-gradient(135deg, #22c55e, #3b82f6);
        border-color: #22c55e;
        color: #fff;
        box-shadow: 0 0 15px rgba(34, 197, 94, 0.4);
      }

      .lane-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .lane-btn:disabled:hover {
        background: rgba(255, 255, 255, 0.05);
        color: #aaa;
        border-color: rgba(255, 255, 255, 0.2);
      }

      #laneCountLabel {
        font-size: 0.7em;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #888;
        margin-bottom: 6px;
        text-align: center;
      }

      /* Difficulty Selection */
      #difficultySelect {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 6px;
        margin-bottom: 12px;
      }

      .diff-btn {
        padding: 6px 4px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: #aaa;
        border-radius: 6px;
        font-family: "Rajdhani", sans-serif;
        font-weight: 600;
        font-size: 0.75em;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .diff-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
      }

      .diff-btn.selected {
        background: var(--accent);
        border-color: var(--accent);
        color: #fff;
      }

      .diff-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      /* Play Controls Container */
      #playControls {
        display: flex;
        gap: 8px;
        margin-bottom: 4px;
      }

      /* Play Button */
      #playBtn {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-family: "Orbitron", sans-serif;
        font-size: 1em;
        font-weight: 700;
        letter-spacing: 2px;
        cursor: pointer;
        transition: all 0.2s ease;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        color: #fff;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      }

      #playBtn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px var(--accent-glow);
      }

      #playBtn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #playBtn.playing {
        background: linear-gradient(135deg, #22c55e, #16a34a);
      }

      #playBtn.paused {
        background: linear-gradient(135deg, #eab308, #ca8a04);
      }

      /* Control Buttons (Stop, Restart) */
      .control-btn {
        width: 40px;
        height: 40px;
        border: none;
        border-radius: 8px;
        font-size: 1.1em;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.1);
        color: #aaa;
        border: 1px solid rgba(255, 255, 255, 0.15);
      }

      .control-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
        transform: translateY(-2px);
      }

      .control-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      #stopBtn:hover:not(:disabled) {
        background: rgba(239, 68, 68, 0.2);
        border-color: rgba(239, 68, 68, 0.4);
        color: #ef4444;
      }

      #restartBtn:hover:not(:disabled) {
        background: rgba(59, 130, 246, 0.2);
        border-color: rgba(59, 130, 246, 0.4);
        color: #3b82f6;
      }

      /* Control hints */
      #controlHints {
        display: flex;
        justify-content: center;
        gap: 16px;
        font-size: 0.7em;
        color: #666;
        margin-top: 6px;
        margin-bottom: 8px;
      }

      #controlHints span {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      #controlHints kbd {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: monospace;
        font-size: 0.95em;
      }

      /* Input Device Selector - Always at bottom of sidebar */
      #inputDeviceSelector {
        padding: 6px;
        background: rgba(0, 0, 0, 0.4);
        border-top: 1px solid rgba(168, 85, 247, 0.2);
        margin-top: auto;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .controller-label {
        font-size: 0.6em;
        color: #555;
        letter-spacing: 1.5px;
        margin-left: 6px;
      }

      .input-device-grid {
        display: flex;
        gap: 12px;
        flex: 1;
      }

      .input-device-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2px;
        padding: 8px 4px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        transition: all 0.2s ease;
        cursor: pointer;
        color: #888;
        flex: 1;
        height: 40px;
      }

      .input-device-btn:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.15);
      }

      .input-device-btn:disabled {
        opacity: 0.35;
        cursor: not-allowed;
      }

      .input-device-btn.selected {
        background: rgba(139, 92, 246, 0.2);
        border-color: rgba(139, 92, 246, 0.5);
        box-shadow: 0 0 10px rgba(139, 92, 246, 0.2);
        color: #fff;
      }

      .input-device-btn.connected:not(.selected) {
        opacity: 1;
        background: rgba(34, 197, 94, 0.1);
        border-color: rgba(34, 197, 94, 0.3);
      }

      .input-device-btn.connected:not(.selected):hover {
        background: rgba(34, 197, 94, 0.2);
        border-color: rgba(34, 197, 94, 0.5);
      }

      .device-icon {
        font-size: 1.2em;
        line-height: 1;
      }

      .device-name {
        display: none;
      }

      .device-status {
        display: none;
        font-size: 0.8em;
      }

      .input-device-btn.selected .device-status {
        display: block;
        color: #a855f7;
      }

      .input-device-btn.connected:not(.selected) .device-status {
        display: block;
        color: #22c55e;
      }

      /* Pulse animation for newly connected device */
      @keyframes device-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.03);
        }
      }

      .input-device-btn.just-connected {
        animation: device-pulse 0.5s ease;
        animation-iteration-count: 3;
      }

      /* Legal Footer */
      #legalFooter {
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.3);
        border-top: 1px solid rgba(168, 85, 247, 0.15);
        display: flex;
        justify-content: center;
        gap: 16px;
        flex-shrink: 0;
      }

      #legalFooter a {
        color: #666;
        text-decoration: none;
        font-size: 0.7em;
        transition: color 0.2s;
      }

      #legalFooter a:hover {
        color: var(--accent);
      }

      #legalFooter span {
        color: #444;
        font-size: 0.7em;
      }

      /* Loading overlay */
      #loading {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: var(--bg-dark);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        gap: 20px;
        z-index: 1000;
        transition: opacity 0.3s ease;
      }

      #loading.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .spinner {
        width: 48px;
        height: 48px;
        border: 4px solid rgba(168, 85, 247, 0.2);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Left Panel */
      #leftPanel {
        padding-top: 24px;
        width: 380px;
        flex-shrink: 0;
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border-right: 1px solid rgba(168, 85, 247, 0.3);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        position: relative;
        z-index: 10;
      }

      #leftPanel .panel-section {
        padding-left: 24px;
        padding-right: 24px;
        margin-bottom: 20px;
      }

      #leftPanel .section-label {
        font-size: 0.7em;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--accent);
        margin-bottom: 8px;
        font-weight: 600;
      }

      /* Score display */
      #scoreDisplay {
        font-family: "Orbitron", sans-serif;
      }

      #scoreDisplay .score {
        font-size: 2.8em;
        font-weight: 900;
        background: linear-gradient(135deg, #fff, var(--accent));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        text-shadow: none;
        filter: drop-shadow(0 0 20px var(--accent-glow));
      }

      #scoreDisplay .combo {
        font-size: 1.2em;
        color: var(--accent);
        display: none; /* Hidden - using new comboDisplay instead */
      }

      #scoreDisplay .multiplier {
        font-size: 1em;
        color: #888;
      }

      /* NEW COMBO DISPLAY - Centered below the note highway */
      #comboDisplay {
        position: absolute;
        left: 50%;
        bottom: 15px;
        transform: translateX(-50%);
        z-index: 100;
        font-family: "Orbitron", sans-serif;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.15s ease;
      }

      #comboDisplay.visible {
        opacity: 1;
      }

      #comboDisplay .combo-number {
        font-size: 4.5em;
        font-weight: 900;
        line-height: 1;
        color: #fff;
        text-shadow: 0 0 20px rgba(168, 85, 247, 0.8),
          0 0 40px rgba(168, 85, 247, 0.5), 0 0 60px rgba(168, 85, 247, 0.3);
        transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1),
          color 0.3s ease, text-shadow 0.3s ease;
      }

      #comboDisplay .combo-label {
        font-size: 1.2em;
        font-weight: 700;
        letter-spacing: 0.4em;
        color: rgba(255, 255, 255, 0.7);
        margin-top: -5px;
        text-transform: uppercase;
      }

      #comboDisplay .multiplier-badge {
        position: absolute;
        top: -10px;
        right: -60px;
        font-size: 1.8em;
        font-weight: 900;
        color: #fbbf24;
        text-shadow: 0 0 15px rgba(251, 191, 36, 0.8);
      }

      /* Combo bump animation on hit */
      #comboDisplay.bump .combo-number {
        animation: comboBump 0.12s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      @keyframes comboBump {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.15);
        }
        100% {
          transform: scale(1);
        }
      }

      /* Combo break effect */
      #comboDisplay.breaking {
        animation: comboBreak 0.4s ease forwards;
      }

      @keyframes comboBreak {
        0% {
          transform: translateX(-50%) scale(1);
          opacity: 1;
        }
        30% {
          transform: translateX(-50%) scale(1.3);
          opacity: 1;
          filter: hue-rotate(-30deg);
        }
        100% {
          transform: translateX(-50%) scale(0.5) translateY(30px);
          opacity: 0;
          filter: blur(10px);
        }
      }

      /* Particle container for combo effects */
      #comboParticles {
        position: absolute;
        left: 50%;
        bottom: 15px;
        width: 300px;
        height: 150px;
        transform: translateX(-50%);
        pointer-events: none;
        z-index: 99;
        overflow: visible;
      }

      .combo-particle {
        position: absolute;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        pointer-events: none;
        animation: particleFloat 0.8s ease-out forwards;
      }

      @keyframes particleFloat {
        0% {
          opacity: 1;
          transform: translate(0, 0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(var(--dx), var(--dy)) scale(0);
        }
      }

      /* Screen shake for milestones */
      #gameArea.screen-shake {
        animation: screenShake 0.3s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;
      }

      @keyframes screenShake {
        0%,
        100% {
          transform: translateX(0);
        }
        10% {
          transform: translateX(-5px) rotate(-0.5deg);
        }
        20% {
          transform: translateX(5px) rotate(0.5deg);
        }
        30% {
          transform: translateX(-4px) rotate(-0.3deg);
        }
        40% {
          transform: translateX(4px) rotate(0.3deg);
        }
        50% {
          transform: translateX(-3px) rotate(-0.2deg);
        }
        60% {
          transform: translateX(3px) rotate(0.2deg);
        }
        70% {
          transform: translateX(-2px) rotate(-0.1deg);
        }
        80% {
          transform: translateX(2px) rotate(0.1deg);
        }
        90% {
          transform: translateX(-1px);
        }
      }

      /* Milestone flash overlay */
      #milestoneFlash {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        pointer-events: none;
        z-index: 200;
        opacity: 0;
      }

      #milestoneFlash.flash {
        animation: milestoneFlash 0.5s ease-out forwards;
      }

      @keyframes milestoneFlash {
        0% {
          opacity: 0.7;
          background: radial-gradient(
            circle at center,
            rgba(255, 255, 255, 0.8),
            transparent 70%
          );
        }
        100% {
          opacity: 0;
          background: radial-gradient(
            circle at center,
            rgba(255, 255, 255, 0),
            transparent 70%
          );
        }
      }

      #milestoneFlash.flash-gold {
        animation: milestoneFlashGold 0.6s ease-out forwards;
      }

      @keyframes milestoneFlashGold {
        0% {
          opacity: 0.8;
          background: radial-gradient(
            circle at center,
            rgba(255, 215, 0, 0.9),
            rgba(251, 146, 60, 0.5) 50%,
            transparent 70%
          );
        }
        100% {
          opacity: 0;
          background: radial-gradient(
            circle at center,
            rgba(255, 215, 0, 0),
            transparent 70%
          );
        }
      }

      /* Combo milestone text popup */
      #milestoneText {
        position: absolute;
        left: 50%;
        top: 35%;
        transform: translateX(-50%);
        font-family: "Orbitron", sans-serif;
        font-size: 3em;
        font-weight: 900;
        text-align: center;
        pointer-events: none;
        z-index: 201;
        opacity: 0;
      }

      #milestoneText.show {
        animation: milestoneTextPop 1.2s cubic-bezier(0.34, 1.56, 0.64, 1)
          forwards;
      }

      @keyframes milestoneTextPop {
        0% {
          opacity: 0;
          transform: translateX(-50%) scale(0.5);
        }
        15% {
          opacity: 1;
          transform: translateX(-50%) scale(1.2);
        }
        30% {
          transform: translateX(-50%) scale(1);
        }
        70% {
          opacity: 1;
          transform: translateX(-50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translateX(-50%) scale(1.5) translateY(-30px);
        }
      }

      /* Loading Phrase Overlay - shown before song starts */
      #loadingPhraseOverlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 40px;
        text-align: center;
        background: linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.8) 0%,
          rgba(0, 0, 0, 0.6) 50%,
          rgba(0, 0, 0, 0.8) 100%
        );
        pointer-events: none;
        z-index: 150;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.5s ease, visibility 0.5s ease;
      }

      #loadingPhraseOverlay.show {
        opacity: 1;
        visibility: visible;
      }

      #loadingPhraseOverlay.fade-out {
        opacity: 0;
        visibility: hidden;
      }

      #loadingPhraseSong {
        font-family: "Orbitron", sans-serif;
        font-size: 2em;
        font-weight: 700;
        color: #fff;
        text-shadow: 0 2px 20px rgba(168, 85, 247, 0.5);
        margin-bottom: 8px;
        animation: slideIn 0.5s ease-out;
      }

      #loadingPhraseArtist {
        font-family: "Rajdhani", sans-serif;
        font-size: 1.3em;
        color: #a855f7;
        margin-bottom: 24px;
        animation: slideIn 0.5s ease-out 0.1s both;
      }

      #loadingPhraseText {
        font-family: "Rajdhani", sans-serif;
        font-size: 1.1em;
        color: #ccc;
        font-style: italic;
        max-width: 500px;
        line-height: 1.5;
        animation: slideIn 0.5s ease-out 0.2s both;
      }

      #loadingPhraseText:empty {
        display: none;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Stats display */
      #statsDisplay {
        font-family: "Rajdhani", sans-serif;
        text-align: left;
      }

      #statsDisplay .stat {
        font-size: 1.1em;
        margin-bottom: 6px;
        display: flex;
        justify-content: space-between;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 6px;
        border-left: 3px solid transparent;
      }

      #statsDisplay .stat.perfect {
        border-left-color: #ffffff;
      }

      #statsDisplay .stat.good {
        border-left-color: var(--lane-green);
      }

      #statsDisplay .stat.ok {
        border-left-color: var(--lane-yellow);
      }

      #statsDisplay .stat.missed {
        border-left-color: var(--lane-red);
      }

      #statsDisplay .stat span:first-child {
        color: #888;
      }

      #statsDisplay .stat span:last-child {
        color: #fff;
        font-weight: 700;
        font-family: "Orbitron", sans-serif;
      }

      #statsDisplay .stat.perfect span:last-child {
        color: #ffffff;
      }

      #statsDisplay .stat.good span:last-child {
        color: var(--lane-green);
      }

      #statsDisplay .stat.ok span:last-child {
        color: var(--lane-yellow);
      }

      #statsDisplay .stat.missed span:last-child {
        color: var(--lane-red);
      }

      #statsDisplay .stat.maxcombo {
        border-left-color: var(--accent);
        margin-top: 8px;
      }

      #statsDisplay .stat.maxcombo span:last-child {
        color: var(--accent);
      }

      /* Drop zone for files */
      #dropZone {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(168, 85, 247, 0.3);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        font-family: "Orbitron", sans-serif;
        font-size: 2em;
        color: #fff;
        border: 4px dashed var(--accent);
      }

      #dropZone.active {
        display: flex;
      }

      /* Lyrics Display */
      #lyricsSection {
        margin-top: auto;
      }

      #lyricsSection .section-label {
        padding-left: 24px;
      }

      #lyricsSection.hidden {
        display: none;
      }

      #lyricsDisplay {
        text-align: center;
        pointer-events: none;
        padding: 0 16px;
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.05) 0%,
          rgba(255, 255, 255, 0.02) 100%
        );
        border-radius: 10px;
        border: 1px solid rgba(168, 85, 247, 0.2);
        height: 280px;
        overflow-y: auto;
        overflow-x: hidden;
        position: relative;
        /* Smooth fade effect at top and bottom */
        mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          rgba(0, 0, 0, 0.3) 15%,
          rgba(0, 0, 0, 1) 35%,
          rgba(0, 0, 0, 1) 65%,
          rgba(0, 0, 0, 0.3) 85%,
          transparent 100%
        );
        -webkit-mask-image: linear-gradient(
          to bottom,
          transparent 0%,
          rgba(0, 0, 0, 0.3) 15%,
          rgba(0, 0, 0, 1) 35%,
          rgba(0, 0, 0, 1) 65%,
          rgba(0, 0, 0, 0.3) 85%,
          transparent 100%
        );
        scroll-behavior: smooth;
      }

      #lyricsDisplay::-webkit-scrollbar {
        width: 0px;
        display: none;
      }

      #lyricsDisplay::-webkit-scrollbar-track {
        background: transparent;
      }

      #lyricsDisplay::-webkit-scrollbar-thumb {
        background: transparent;
      }

      /* Spacer for centering first/last lyrics */
      .lyrics-spacer {
        height: 120px;
      }

      /* Song Progress Bar */
      #songProgressBar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 4px;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      #songProgressBar.active {
        opacity: 1;
      }

      #songProgressFill {
        height: 100%;
        width: 0%;
        background: linear-gradient(90deg, var(--accent), #ec4899);
        box-shadow: 0 0 8px var(--accent-glow), 0 0 4px rgba(236, 72, 153, 0.5);
        transition: width 0.1s linear;
      }

      .lyric-phrase {
        font-family: "Rajdhani", sans-serif;
        font-size: 1em;
        font-weight: 500;
        color: rgba(255, 255, 255, 0.35);
        line-height: 1.6;
        padding: 6px 8px;
        margin: 0;
        transition: all 0.3s ease;
        opacity: 0.6;
      }

      /* Distance-based styling - closer to active = more visible */
      .lyric-phrase.near-1 {
        opacity: 0.85;
        color: rgba(255, 255, 255, 0.55);
        font-weight: 600;
      }

      .lyric-phrase.near-2 {
        opacity: 0.7;
        color: rgba(255, 255, 255, 0.45);
      }

      .lyric-phrase.active {
        font-family: "Rajdhani", sans-serif;
        font-size: 1.25em;
        font-weight: 700;
        color: #fff;
        text-shadow: 0 0 20px rgba(168, 85, 247, 0.6);
        opacity: 1;
        transform: scale(1.02);
      }

      .lyric-phrase.active .sung {
        color: var(--accent);
        text-shadow: 0 0 20px rgba(168, 85, 247, 0.9),
          0 0 40px rgba(168, 85, 247, 0.4);
      }

      .lyric-phrase.past {
        color: rgba(255, 255, 255, 0.2);
        opacity: 0.5;
      }

      .lyric-phrase.past.near-1 {
        opacity: 0.7;
        color: rgba(255, 255, 255, 0.4);
      }

      /* Song Switch Confirmation Modal */
      #switchSongModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(8px);
      }

      #switchSongModal.show {
        display: flex;
        animation: modalFadeIn 0.2s ease;
      }

      @keyframes modalFadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .modal-content {
        background: linear-gradient(145deg, #1a1a2e, #12121a);
        border: 1px solid rgba(168, 85, 247, 0.4);
        border-radius: 16px;
        padding: 32px;
        max-width: 420px;
        text-align: center;
        box-shadow: 0 0 60px rgba(168, 85, 247, 0.3),
          0 20px 40px rgba(0, 0, 0, 0.5);
        animation: modalSlideIn 0.25s ease;
      }

      @keyframes modalSlideIn {
        from {
          transform: scale(0.9) translateY(-20px);
          opacity: 0;
        }
        to {
          transform: scale(1) translateY(0);
          opacity: 1;
        }
      }

      .modal-content h2 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.4em;
        margin-bottom: 16px;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .modal-content p {
        color: #aaa;
        margin-bottom: 24px;
        font-size: 1em;
        line-height: 1.5;
      }

      .modal-song-preview {
        display: flex;
        align-items: center;
        gap: 12px;
        background: rgba(255, 255, 255, 0.05);
        padding: 12px;
        border-radius: 8px;
        margin-bottom: 24px;
        text-align: left;
      }

      .modal-song-preview img {
        width: 48px;
        height: 48px;
        border-radius: 6px;
        object-fit: cover;
      }

      .modal-song-info {
        flex: 1;
        min-width: 0;
      }

      .modal-song-title {
        font-weight: 700;
        font-size: 1em;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        color: #fff;
      }

      .modal-song-artist {
        font-size: 0.85em;
        color: #888;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .modal-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
      }

      .modal-btn {
        padding: 12px 28px;
        border-radius: 8px;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9em;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        border: none;
      }

      .modal-btn-cancel {
        background: rgba(255, 255, 255, 0.1);
        color: #888;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .modal-btn-cancel:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
      }

      .modal-btn-confirm {
        background: linear-gradient(135deg, var(--accent), #ec4899);
        color: #fff;
        box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4);
      }

      .modal-btn-confirm:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(168, 85, 247, 0.5);
      }

      /* Name Entry Modal */
      #nameEntryModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(8px);
      }

      #nameEntryModal.show {
        display: flex;
        animation: modalFadeIn 0.2s ease;
      }

      .name-entry-content {
        background: linear-gradient(145deg, #1a1a2e, #12121a);
        border: 1px solid rgba(255, 215, 0, 0.4);
        border-radius: 16px;
        padding: 32px;
        max-width: 420px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 60px rgba(255, 215, 0, 0.2),
          0 20px 40px rgba(0, 0, 0, 0.5);
        animation: modalSlideIn 0.25s ease;
      }

      .name-entry-content h2 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.6em;
        margin-bottom: 8px;
        background: linear-gradient(135deg, #ffd700, #f59e0b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .final-score-display {
        font-family: "Orbitron", sans-serif;
        font-size: 2.5em;
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 24px;
      }

      .name-entry-content p {
        color: #aaa;
        margin-bottom: 16px;
        font-size: 1em;
        line-height: 1.5;
      }

      .modal-stats {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
        margin-bottom: 20px;
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
      }

      .modal-stat {
        text-align: center;
      }

      .modal-stat-value {
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        font-size: 1.2em;
        display: block;
      }

      .modal-stat-label {
        font-size: 0.7em;
        color: #888;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .modal-stat.perfect .modal-stat-value {
        color: #fff;
      }
      .modal-stat.good .modal-stat-value {
        color: var(--lane-green);
      }
      .modal-stat.ok .modal-stat-value {
        color: var(--lane-yellow);
      }
      .modal-stat.missed .modal-stat-value {
        color: var(--lane-red);
      }
      .modal-stat.combo .modal-stat-value {
        color: var(--accent);
      }

      .name-input-wrapper {
        margin-bottom: 24px;
      }

      #playerNameInput {
        width: 100%;
        padding: 14px 16px;
        font-family: "Orbitron", sans-serif;
        font-size: 1.1em;
        font-weight: 600;
        text-align: center;
        background: rgba(255, 255, 255, 0.08);
        border: 2px solid rgba(168, 85, 247, 0.4);
        border-radius: 10px;
        color: #fff;
        outline: none;
        transition: all 0.2s ease;
      }

      #playerNameInput:focus {
        border-color: var(--accent);
        box-shadow: 0 0 20px rgba(168, 85, 247, 0.3);
      }

      #playerNameInput::placeholder {
        color: #666;
      }

      .name-entry-buttons {
        display: flex;
        gap: 12px;
        justify-content: center;
      }

      .name-entry-btn {
        padding: 12px 28px;
        border-radius: 8px;
        font-family: "Orbitron", sans-serif;
        font-size: 0.9em;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        border: none;
      }

      .name-entry-btn-skip {
        background: rgba(255, 255, 255, 0.1);
        color: #888;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .name-entry-btn-skip:hover {
        background: rgba(255, 255, 255, 0.15);
        color: #fff;
      }

      .name-entry-btn-submit {
        background: linear-gradient(135deg, #ffd700, #f59e0b);
        color: #1a1a2e;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
      }

      .name-entry-btn-submit:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.5);
      }

      .name-entry-btn-submit:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Save Score Prompt Modal */
      #saveScorePrompt {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        z-index: 9999;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(8px);
      }

      #saveScorePrompt.show {
        display: flex;
        animation: modalFadeIn 0.2s ease;
      }

      .save-prompt-content {
        background: linear-gradient(145deg, #1a1a2e, #12121a);
        border: 1px solid rgba(168, 85, 247, 0.4);
        border-radius: 16px;
        padding: 28px;
        max-width: 380px;
        width: 90%;
        text-align: center;
        box-shadow: 0 0 60px rgba(168, 85, 247, 0.2),
          0 20px 40px rgba(0, 0, 0, 0.5);
        animation: modalSlideIn 0.25s ease;
      }

      .save-prompt-content h2 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.3em;
        margin-bottom: 12px;
        color: #fff;
      }

      .save-prompt-score {
        font-family: "Orbitron", sans-serif;
        font-size: 2em;
        font-weight: 700;
        background: linear-gradient(135deg, var(--accent), #ec4899);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 20px;
      }

      .save-prompt-content p {
        color: #888;
        margin-bottom: 20px;
        font-size: 0.95em;
      }

      .save-prompt-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .save-prompt-btn {
        padding: 12px 20px;
        border-radius: 8px;
        font-family: "Orbitron", sans-serif;
        font-size: 0.85em;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s ease;
        border: none;
        width: 100%;
      }

      .save-prompt-btn-save {
        background: linear-gradient(135deg, #ffd700, #f59e0b);
        color: #1a1a2e;
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
      }

      .save-prompt-btn-save:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
      }

      .save-prompt-btn-nosave {
        background: rgba(239, 68, 68, 0.2);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
      }

      .save-prompt-btn-nosave:hover {
        background: rgba(239, 68, 68, 0.3);
      }

      /* Empty State - Get Songs Info */
      #emptyState {
        padding: 8px 0;
      }

      #emptyState.hidden {
        display: none;
      }

      .empty-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 16px;
        padding-bottom: 14px;
        border-bottom: 1px solid rgba(168, 85, 247, 0.2);
      }

      .empty-header .empty-icon {
        font-size: 1.8em;
        filter: drop-shadow(0 0 8px rgba(168, 85, 247, 0.5));
      }

      .empty-header h3 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.1em;
        background: linear-gradient(135deg, #fff, var(--accent));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
      }

      .empty-intro {
        color: #aaa;
        font-size: 0.95em;
        line-height: 1.5;
        margin: 0 0 12px 0;
      }

      .empty-intro strong {
        color: #fff;
      }

      .chorus-link {
        display: flex;
        align-items: center;
        gap: 12px;
        background: linear-gradient(
          135deg,
          rgba(168, 85, 247, 0.15),
          rgba(236, 72, 153, 0.1)
        );
        border: 1px solid rgba(168, 85, 247, 0.3);
        border-radius: 10px;
        padding: 14px 16px;
        text-decoration: none;
        transition: all 0.25s ease;
        margin: 12px 0 16px 0;
      }

      .chorus-link:hover {
        background: linear-gradient(
          135deg,
          rgba(168, 85, 247, 0.25),
          rgba(236, 72, 153, 0.15)
        );
        border-color: rgba(168, 85, 247, 0.5);
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(168, 85, 247, 0.25);
      }

      .chorus-link .link-icon {
        font-size: 1.6em;
        filter: drop-shadow(0 0 8px rgba(168, 85, 247, 0.5));
      }

      .chorus-link .link-info {
        flex: 1;
      }

      .chorus-link .link-title {
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        color: #fff;
        font-size: 1em;
        margin-bottom: 1px;
      }

      .chorus-link .link-url {
        color: var(--accent);
        font-size: 0.8em;
      }

      .chorus-link .link-arrow {
        color: rgba(255, 255, 255, 0.4);
        font-size: 1.3em;
        transition: transform 0.2s ease, color 0.2s ease;
      }

      .chorus-link:hover .link-arrow {
        transform: translateX(4px);
        color: var(--accent);
      }

      .empty-section {
        margin-bottom: 16px;
      }

      .empty-section h4 {
        font-family: "Orbitron", sans-serif;
        font-size: 0.85em;
        color: var(--accent);
        margin: 0 0 10px 0;
      }

      .empty-section ol,
      .empty-section ul {
        color: #999;
        font-size: 0.9em;
        padding-left: 18px;
        margin: 0;
      }

      .empty-section li {
        margin-bottom: 6px;
        line-height: 1.4;
      }

      .empty-section li strong {
        color: #ccc;
      }

      .recommended-section {
        margin: 16px 0;
        padding: 12px;
        background: linear-gradient(
          135deg,
          rgba(234, 179, 8, 0.08),
          rgba(249, 115, 22, 0.05)
        );
        border: 1px solid rgba(234, 179, 8, 0.25);
        border-radius: 10px;
      }

      .recommended-badge {
        font-family: "Orbitron", sans-serif;
        font-size: 0.7em;
        font-weight: 700;
        color: #eab308;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 8px;
      }

      .recommended-section .chorus-link {
        margin: 0;
        background: linear-gradient(
          135deg,
          rgba(234, 179, 8, 0.12),
          rgba(249, 115, 22, 0.08)
        );
        border-color: rgba(234, 179, 8, 0.3);
      }

      .recommended-section .chorus-link:hover {
        background: linear-gradient(
          135deg,
          rgba(234, 179, 8, 0.2),
          rgba(249, 115, 22, 0.12)
        );
        border-color: rgba(234, 179, 8, 0.5);
        box-shadow: 0 8px 25px rgba(234, 179, 8, 0.2);
      }

      .chorus-link .link-desc {
        color: #888;
        font-size: 0.75em;
        margin-top: 2px;
      }

      .empty-tip {
        background: rgba(34, 197, 94, 0.1);
        border: 1px solid rgba(34, 197, 94, 0.25);
        border-radius: 8px;
        padding: 10px 12px;
        font-size: 0.85em;
        color: #aaa;
        line-height: 1.4;
      }

      .empty-tip strong {
        color: #22c55e;
      }

      /* High Scores Section */
      #highScoresSection {
        padding: 24px;
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        min-height: 0; /* Allow flex child to shrink below content size */
      }

      #highScoresSection.hidden {
        display: none;
      }

      #highScoresSection .section-header {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
      }

      #highScoresSection .section-header .trophy-icon {
        font-size: 1.8em;
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6));
      }

      #highScoresSection .section-header h2 {
        font-family: "Orbitron", sans-serif;
        font-size: 1.3em;
        background: linear-gradient(135deg, #ffd700, #f59e0b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin: 0;
        letter-spacing: 2px;
      }

      .high-score-subtitle {
        font-size: 0.85em;
        color: #888;
        margin-bottom: 16px;
        padding-bottom: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .high-score-subtitle .song-name {
        color: var(--accent);
        font-weight: 600;
      }

      .high-score-subtitle.clickable {
        cursor: pointer;
        transition: color 0.2s ease;
      }

      .high-score-subtitle.clickable:hover {
        color: #fff;
      }

      .high-score-subtitle .back-arrow {
        font-size: 1.2em;
        opacity: 0.6;
        transition: opacity 0.2s ease;
      }

      .high-score-subtitle.clickable:hover .back-arrow {
        opacity: 1;
      }

      .high-score-subtitle .view-all-hint {
        font-size: 0.9em;
        opacity: 0.5;
        margin-left: auto;
      }

      .high-score-subtitle.clickable:hover .view-all-hint {
        opacity: 0.8;
      }

      .high-score-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
        overflow-y: auto;
        min-height: 0;
        padding-right: 4px; /* Space for scrollbar */
      }

      .high-score-list::-webkit-scrollbar {
        width: 6px;
      }

      .high-score-list::-webkit-scrollbar-track {
        background: transparent;
      }

      .high-score-list::-webkit-scrollbar-thumb {
        background: var(--accent);
        border-radius: 3px;
      }

      .high-score-list::-webkit-scrollbar-thumb:hover {
        background: #c084fc;
      }

      .high-score-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px 14px;
        background: rgba(255, 255, 255, 0.03);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 10px;
        transition: all 0.2s ease;
      }

      .high-score-item:hover {
        background: rgba(168, 85, 247, 0.08);
        border-color: rgba(168, 85, 247, 0.2);
      }

      .high-score-rank {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: "Orbitron", sans-serif;
        font-weight: 900;
        font-size: 0.95em;
        border-radius: 50%;
        flex-shrink: 0;
        background: rgba(255, 255, 255, 0.1);
        color: #888;
      }

      .high-score-info {
        flex: 1;
        min-width: 0;
      }

      .high-score-name {
        font-weight: 700;
        font-size: 0.95em;
        color: #fff;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .high-score-song {
        font-size: 0.8em;
        color: var(--accent);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        opacity: 0.85;
      }

      .high-score-artist {
        color: #888;
        font-style: italic;
        font-weight: 400;
      }

      .high-score-date {
        font-size: 0.75em;
        color: #666;
      }

      .high-score-score {
        font-family: "Orbitron", sans-serif;
        font-weight: 700;
        font-size: 1.1em;
        background: linear-gradient(135deg, #fff, var(--accent));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        flex-shrink: 0;
      }

      .high-score-item.gold .high-score-score {
        background: linear-gradient(135deg, #ffd700, #f59e0b);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.4));
      }

      .high-score-stats {
        display: flex;
        gap: 6px;
        margin-top: 4px;
        font-size: 0.7em;
        font-family: "Orbitron", sans-serif;
      }

      .high-score-stats .hs-stat {
        padding: 2px 5px;
        border-radius: 4px;
        background: rgba(255, 255, 255, 0.05);
      }

      .high-score-stats .hs-stat.compact {
        color: #666;
      }
      .high-score-stats .hs-stat.compact .perfect {
        color: #fff;
      }
      .high-score-stats .hs-stat.compact .good {
        color: var(--lane-green);
      }
      .high-score-stats .hs-stat.compact .ok {
        color: var(--lane-yellow);
      }
      .high-score-stats .hs-stat.compact .missed {
        color: var(--lane-red);
      }
      .high-score-stats .hs-stat.compact .combo {
        color: var(--accent);
      }
      .high-score-stats .hs-stat.lanes {
        color: #a855f7;
        font-weight: 600;
      }
      .high-score-stats .hs-stat.instrument {
        font-size: 1.1em;
        padding: 0 3px;
        background: transparent;
      }
      .high-score-stats .hs-stat.input-device {
        font-size: 1.1em;
        padding: 0 3px;
        background: transparent;
      }

      .no-high-scores {
        text-align: center;
        padding: 40px 20px;
        color: #666;
      }

      .no-high-scores .empty-icon {
        font-size: 3em;
        margin-bottom: 12px;
        opacity: 0.5;
      }

      .no-high-scores p {
        font-size: 0.95em;
        margin: 0;
      }

      /* Left panel section visibility */
      #scoreSection.hidden,
      #statsSection.hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="loading">
      <div class="spinner"></div>
      <div>Scanning songs...</div>
    </div>

    <div id="dropZone">Drop songs or folders here</div>

    <!-- Song Switch Confirmation Modal -->
    <div id="switchSongModal">
      <div class="modal-content">
        <h2>Switch Song?</h2>
        <p>
          You're currently playing. Do you want to stop and switch to this song?
        </p>
        <div class="modal-song-preview">
          <img id="modalAlbumArt" src="" alt="Album art" />
          <div class="modal-song-info">
            <div class="modal-song-title" id="modalSongTitle"></div>
            <div class="modal-song-artist" id="modalSongArtist"></div>
          </div>
        </div>
        <div class="modal-buttons">
          <button class="modal-btn modal-btn-cancel" id="modalCancelBtn">
            Cancel
          </button>
          <button class="modal-btn modal-btn-confirm" id="modalConfirmBtn">
            Switch Song
          </button>
        </div>
      </div>
    </div>

    <!-- Name Entry Modal (shown after song completion) -->
    <div id="nameEntryModal">
      <div class="name-entry-content">
        <h2>üèÜ Song Complete!</h2>
        <div class="final-score-display" id="finalScoreDisplay">0</div>
        <div class="modal-stats">
          <div class="modal-stat perfect">
            <span class="modal-stat-value" id="modalPerfect">0</span>
            <span class="modal-stat-label">Perfect</span>
          </div>
          <div class="modal-stat good">
            <span class="modal-stat-value" id="modalGood">0</span>
            <span class="modal-stat-label">Good</span>
          </div>
          <div class="modal-stat ok">
            <span class="modal-stat-value" id="modalOk">0</span>
            <span class="modal-stat-label">OK</span>
          </div>
          <div class="modal-stat missed">
            <span class="modal-stat-value" id="modalMissed">0</span>
            <span class="modal-stat-label">Missed</span>
          </div>
          <div class="modal-stat combo">
            <span class="modal-stat-value" id="modalMaxCombo">0</span>
            <span class="modal-stat-label">Max Combo</span>
          </div>
        </div>
        <p>Enter your name for the leaderboard:</p>
        <div class="name-input-wrapper">
          <input
            type="text"
            id="playerNameInput"
            placeholder="Your Name"
            maxlength="20"
            autocomplete="off"
          />
        </div>
        <div class="name-entry-buttons">
          <button class="name-entry-btn name-entry-btn-skip" id="skipScoreBtn">
            Skip
          </button>
          <button
            class="name-entry-btn name-entry-btn-submit"
            id="submitScoreBtn"
          >
            Submit Score
          </button>
        </div>
      </div>
    </div>

    <!-- Save Score Prompt (shown before stopping/restarting/switching) -->
    <div id="saveScorePrompt">
      <div class="save-prompt-content">
        <h2>Save Your Score?</h2>
        <div class="save-prompt-score" id="promptScoreDisplay">0</div>
        <p>Would you like to save your score before leaving?</p>
        <div class="save-prompt-buttons">
          <button
            class="save-prompt-btn save-prompt-btn-save"
            id="promptSaveBtn"
          >
            Save Score
          </button>
          <button
            class="save-prompt-btn save-prompt-btn-nosave"
            id="promptNoSaveBtn"
          >
            Don't Save
          </button>
        </div>
      </div>
    </div>

    <div id="appScaler">
      <!-- Video container inside appScaler so it scales with the 16:9 container -->
      <div id="videoContainer">
        <img id="backgroundImage" alt="" />
        <video id="backgroundVideo" muted playsinline></video>
        <div id="videoOverlay"></div>
        <div id="videoGlow"></div>
      </div>

      <div id="app">
        <div id="leftPanel">
          <!-- Score Section - shown during/after gameplay -->
          <div id="scoreSection" class="panel-section hidden">
            <div class="section-label">Score</div>
            <div id="scoreDisplay">
              <div class="score" id="score">0</div>
              <div class="combo" id="combo"></div>
              <div class="multiplier" id="multiplier"></div>
            </div>
          </div>

          <!-- Stats Section - shown during/after gameplay -->
          <div id="statsSection" class="panel-section hidden">
            <div class="section-label">Stats</div>
            <div id="statsDisplay">
              <div class="stat perfect">
                <span>Perfect</span> <span id="perfectCount">0</span>
              </div>
              <div class="stat good">
                <span>Good</span> <span id="goodCount">0</span>
              </div>
              <div class="stat ok">
                <span>OK</span> <span id="okCount">0</span>
              </div>
              <div class="stat missed">
                <span>Missed</span> <span id="missedCount">0</span>
              </div>
              <div class="stat maxcombo">
                <span>Max Combo</span> <span id="maxComboCount">0</span>
              </div>
            </div>
          </div>

          <!-- High Scores Section - shown when idle or after song completion -->
          <div id="highScoresSection">
            <div class="section-header">
              <span class="trophy-icon">üèÜ</span>
              <h2>HIGH SCORES</h2>
            </div>
            <div class="high-score-subtitle" id="highScoreSubtitle">
              All Songs
            </div>
            <div class="high-score-list" id="highScoreList">
              <!-- Populated dynamically by JavaScript -->
            </div>
          </div>

          <!-- Lyrics Section -->
          <div id="lyricsSection" class="hidden">
            <div class="section-label">Lyrics</div>
            <div id="lyricsDisplay"></div>
          </div>
        </div>
        <div id="gameArea">
          <div id="gameScaler">
            <canvas id="gameCanvas"></canvas>

            <!-- New Combo Display -->
            <div id="comboDisplay">
              <span class="multiplier-badge" id="comboMultiplier"></span>
              <div class="combo-number" id="comboNumber">0</div>
              <div class="combo-label">COMBO</div>
            </div>
            <div id="comboParticles"></div>

            <!-- Milestone Effects -->
            <div id="milestoneFlash"></div>
            <div id="milestoneText"></div>

            <!-- Loading Phrase Overlay -->
            <div id="loadingPhraseOverlay">
              <div id="loadingPhraseSong"></div>
              <div id="loadingPhraseArtist"></div>
              <div id="loadingPhraseText"></div>
            </div>

            <div id="songProgressBar">
              <div id="songProgressFill"></div>
            </div>
          </div>
        </div>

        <div id="sidebar">
          <div id="logo">
            <h1>BEAT FRENZY</h1>
            <p>Clone Hero Song Player</p>
          </div>

          <div id="searchContainer">
            <div id="searchRow">
              <div id="searchWrapper">
                <input
                  type="text"
                  id="searchInput"
                  placeholder="Search songs..."
                  autocomplete="off"
                />
                <button id="clearSearch" type="button">‚úï</button>
              </div>
              <button
                id="openFolderBtn"
                onclick="openSongsFolder()"
                title="Open songs folder"
              >
                üìÅ
              </button>
            </div>
            <div id="filterRow">
              <select id="decadeFilter">
                <option value="">All Decades</option>
              </select>
              <select id="sortSelect">
                <option value="name">Sort: Name</option>
                <option value="artist">Sort: Artist</option>
                <option value="difficulty">Sort: Difficulty</option>
                <option value="duration">Sort: Duration</option>
                <option value="year">Sort: Year</option>
              </select>
              <label id="videoFilterLabel">
                <input type="checkbox" id="videoFilter" />
                <span class="checkbox-icon"></span>
                <span>üé¨ Videos</span>
              </label>
            </div>

            <button id="clearFilters" type="button">‚úï Clear Filters</button>
            <div id="songCount"></div>
          </div>

          <div id="songList">
            <!-- Empty state with song download info shown by default -->
            <div id="emptyState">
              <div class="empty-header">
                <span class="empty-icon">üé∏</span>
                <h3>Get Songs to Play</h3>
              </div>

              <p class="empty-intro">
                Download free songs from <strong>Chorus Encore</strong> ‚Äî
                thousands of community-created charts!
              </p>

              <a
                href="https://www.enchor.us/"
                target="_blank"
                rel="noopener noreferrer"
                class="chorus-link"
              >
                <span class="link-icon">üéµ</span>
                <div class="link-info">
                  <div class="link-title">Chorus Encore</div>
                  <div class="link-url">enchor.us</div>
                </div>
                <span class="link-arrow">‚Üí</span>
              </a>

              <div class="recommended-section">
                <div class="recommended-badge">‚≠ê Highly Recommended</div>
                <a
                  href="https://drive.google.com/drive/folders/11ktdxfSCQlodmCoN89OxyLWy-e3CsTlO"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="chorus-link featured"
                >
                  <span class="link-icon">üé∏</span>
                  <div class="link-info">
                    <div class="link-title">Sang Duta's Collection</div>
                    <div class="link-desc">
                      50+ quality charts ‚Äî EDM, metal, pop & more
                    </div>
                  </div>
                  <span class="link-arrow">‚Üí</span>
                </a>
              </div>

              <div class="empty-section">
                <h4>üì• How to Get Started</h4>
                <ol>
                  <li>Search for songs by title or artist</li>
                  <li>Download the <strong>.zip</strong> file</li>
                  <li><strong>Extract</strong> the zip to a folder</li>
                  <li>
                    <strong>Drag & drop</strong> the folder here, or click üìÅ
                  </li>
                </ol>
              </div>

              <div class="empty-tip">
                üí° <strong>Pro tip:</strong> Download entire "setlists" to
                quickly build your library!
              </div>
            </div>
          </div>

          <div id="nowPlaying" class="collapsed no-song">
            <div id="nowPlayingHeader">
              <h3><span class="collapse-icon">‚ñº</span> Now Playing</h3>
            </div>

            <!-- Mini player shown when collapsed -->
            <div id="miniPlayer">
              <img id="miniAlbumArt" src="" alt="Album" />
              <div class="mini-info">
                <div class="mini-title" id="miniSongTitle">Select a song</div>
                <div class="mini-artist" id="miniArtist">‚Äî</div>
              </div>
              <button class="mini-play-btn" id="miniPlayBtn" disabled>‚ñ∂</button>
            </div>

            <div id="nowPlayingContent">
              <div id="songInfoRow">
                <div id="albumArtContainer">
                  <img id="albumArt" src="" alt="Album Art" />
                  <div id="videoIndicator">
                    <span class="icon">üé¨</span>
                    <span>Video</span>
                  </div>
                </div>
                <div id="songDetails">
                  <div id="currentSong">Select a song</div>
                  <div id="currentArtist">‚Äî</div>
                  <div id="songMeta">
                    <span id="songYear"></span>
                    <span id="songDuration"></span>
                  </div>
                  <div id="loadingPhrase"></div>
                </div>
              </div>

              <div id="instrumentSelect">
                <button
                  class="instrument-btn selected"
                  data-instrument="guitar"
                  disabled
                >
                  <span class="icon">üé∏</span>
                  <span class="name">Guitar</span>
                </button>
                <button class="instrument-btn" data-instrument="bass" disabled>
                  <span class="icon">üé∏</span>
                  <span class="name">Bass</span>
                </button>
                <button class="instrument-btn" data-instrument="drums" disabled>
                  <span class="icon">ü•Å</span>
                  <span class="name">Drums</span>
                </button>
                <button class="instrument-btn" data-instrument="keys" disabled>
                  <span class="icon">üéπ</span>
                  <span class="name">Keys</span>
                </button>
              </div>

              <div id="difficultySelect">
                <button class="diff-btn" data-diff="Easy">Easy</button>
                <button class="diff-btn" data-diff="Medium">Medium</button>
                <button class="diff-btn selected" data-diff="Hard">Hard</button>
                <button class="diff-btn" data-diff="Expert">Expert</button>
              </div>

              <div id="laneCountLabel">Lane Count</div>
              <div id="laneCountSelect">
                <button class="lane-btn" data-lanes="1">1</button>
                <button class="lane-btn" data-lanes="2">2</button>
                <button class="lane-btn" data-lanes="3">3</button>
                <button class="lane-btn" data-lanes="4">4</button>
                <button class="lane-btn selected" data-lanes="5">5</button>
              </div>

              <div id="playControls">
                <button id="playBtn" disabled>SELECT SONG</button>
                <button
                  id="stopBtn"
                  class="control-btn"
                  disabled
                  title="Stop (Esc)"
                >
                  ‚èπ
                </button>
                <button
                  id="restartBtn"
                  class="control-btn"
                  disabled
                  title="Restart"
                >
                  ‚Ü∫
                </button>
              </div>

              <div id="controlHints">
                <span><kbd>Space</kbd>/<kbd>P</kbd> Play/Pause</span>
                <span><kbd>Esc</kbd> Stop</span>
              </div>
            </div>
          </div>

          <!-- Input Device Selector - Always visible at bottom -->
          <div id="inputDeviceSelector">
            <div class="controller-label">INPUT DEVICE</div>
            <div class="input-device-grid">
              <button
                class="input-device-btn selected"
                data-device="keyboard"
                id="keyboardDevice"
              >
                <span class="device-icon">‚å®Ô∏è</span>
                <span class="device-name">Keyboard</span>
                <span class="device-status">Ready</span>
              </button>
              <button
                class="input-device-btn"
                data-device="drums"
                id="drumsDevice"
                disabled
              >
                <span class="device-icon">ü•Å</span>
                <span class="device-name">Drums</span>
                <span class="device-status">Disconnected</span>
              </button>
              <button
                class="input-device-btn"
                data-device="guitar"
                id="guitarDevice"
                disabled
              >
                <span class="device-icon">üé∏</span>
                <span class="device-name">Guitar</span>
                <span class="device-status">Disconnected</span>
              </button>
              <button
                class="input-device-btn"
                data-device="procontroller"
                id="procontrollerDevice"
                disabled
              >
                <span class="device-icon">üéÆ</span>
                <span class="device-name">Pro Controller</span>
                <span class="device-status">Disconnected</span>
              </button>
            </div>
          </div>

          <!-- Legal Footer -->
          <div id="legalFooter">
            <a href="./terms.html" target="_blank">Terms of Service</a>
            <span>‚Ä¢</span>
            <a href="./privacy.html" target="_blank">Privacy Policy</a>
          </div>
        </div>
      </div>
    </div>
    <!-- closes #appScaler -->

    <script>
      // ============================================
      // BEAT FRENZY - Clone Hero Song Player
      // ============================================

      // Polyfill for roundRect (not supported in all browsers)
      if (!CanvasRenderingContext2D.prototype.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (
          x,
          y,
          w,
          h,
          r
        ) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      // ============================================
      // FIXED RESOLUTION - Consistent across all devices
      // ============================================
      const GAME_WIDTH = 1600;
      const GAME_HEIGHT = 900;

      // Key-to-color mapping: each key always has the same color regardless of lane count
      const KEY_COLORS = {
        a: "#22c55e", // green
        s: "#ef4444", // red
        d: "#eab308", // yellow
        f: "#3b82f6", // blue
        g: "#f97316", // orange
      };
      const ALL_LANE_KEYS = ["a", "s", "d", "f", "g"];
      const ALL_LANE_COLORS = ALL_LANE_KEYS.map((key) => KEY_COLORS[key]);

      // Dynamic lane configuration based on selected lane count
      let activeLaneCount = 5;

      // Update game area min-width based on lane count
      // (No longer needed with fixed resolution, kept for compatibility)
      function updateGameAreaMinWidth() {
        // Fixed resolution handles all sizing now
      }

      // Get the colors for the current lane count (based on active keys)
      function getLaneColors() {
        const keys = getLaneKeys();
        return keys.map((key) => KEY_COLORS[key]);
      }

      // Get the keys for the current lane count
      function getLaneKeys() {
        if (activeLaneCount === 5) return ALL_LANE_KEYS;
        if (activeLaneCount === 4) return ["a", "s", "d", "f"];
        if (activeLaneCount === 3) return ["s", "d", "f"];
        if (activeLaneCount === 2) return ["d", "f"];
        return ["f"]; // center key for 1 lane
      }

      // Map a 5-lane note to the current lane count
      function mapLaneToActive(originalLane) {
        if (activeLaneCount === 5) return originalLane;
        // Use proportional mapping: distribute lanes evenly
        return Math.round((originalLane * (activeLaneCount - 1)) / 4);
      }

      // Remap notes from 5 lanes to the current lane count with deduplication
      function remapNotesToLanes(notes) {
        if (activeLaneCount === 5) return notes;

        // Map each note to new lane
        const remappedNotes = notes.map((note) => ({
          ...note,
          originalLane: note.lane,
          lane: mapLaneToActive(note.lane),
        }));

        // Sort by time for deduplication
        remappedNotes.sort((a, b) => a.time - b.time || a.lane - b.lane);

        // Deduplicate notes that are too close together in the same lane
        const dedupedNotes = [];
        const MIN_NOTE_GAP = 50; // Minimum 50ms between notes in the same lane

        for (const note of remappedNotes) {
          // Check if there's already a note in this lane within the time threshold
          const conflictingNote = dedupedNotes.find(
            (n) =>
              n.lane === note.lane &&
              Math.abs(n.time - note.time) < MIN_NOTE_GAP
          );

          if (!conflictingNote) {
            dedupedNotes.push(note);
          } else {
            // Keep the note with longer sustain, or merge sustains
            if (note.durationMs > conflictingNote.durationMs) {
              conflictingNote.durationMs = note.durationMs;
            }
          }
        }

        return dedupedNotes.sort((a, b) => a.time - b.time);
      }

      // Game configuration
      const CONFIG = {
        noteSpeed: 800, // pixels per second
        hitLineY: 150, // pixels from bottom (raised to make room for combo display)
        noteHeight: 24,
        laneWidth: 80,
        hitWindow: {
          perfect: 45,
          good: 90,
          okay: 140,
        },
        points: {
          perfect: 100,
          good: 50,
          okay: 25,
          sustainTick: 10,
          sustainComplete: 50,
        },
        sustainTickInterval: 100, // Award tick points every 100ms
        // Grace period for sustain releases - INTENTIONALLY ASYMMETRIC:
        // - Before end: up to this many ms early still counts as held
        // - After end: unlimited (holding longer than required is never penalized)
        sustainGracePeriod: 250,
      };

      // Lane difficulty multiplier - more lanes = higher score potential
      function getLaneDifficultyMultiplier() {
        // 5 lanes = 1.0x (hardest)
        // 4 lanes = 0.8x
        // 3 lanes = 0.6x
        // 2 lanes = 0.4x
        // 1 lane = 0.2x
        return activeLaneCount / 5;
      }

      // ============================================
      // AUDIO FEEDBACK - Volume-based system
      // ============================================

      // Volume control based on performance
      const VOLUME_CONFIG = {
        normalVolume: 1.0, // Full volume when hitting notes
        missVolume: 0.25, // Quieter volume when missing
        recoveryRate: 0.15, // How fast volume recovers per hit
        dropAmount: 0.4, // How much volume drops per miss
        smoothingSpeed: 0.08, // How fast volume transitions (lower = smoother)
      };

      let targetVolume = VOLUME_CONFIG.normalVolume;
      let currentVolume = VOLUME_CONFIG.normalVolume;
      let volumeAnimationId = null;

      // Smoothly animate volume towards target
      function updateVolume() {
        if (!gameState.audioElement) return;

        // Smoothly interpolate current volume towards target
        const diff = targetVolume - currentVolume;
        if (Math.abs(diff) > 0.01) {
          currentVolume += diff * VOLUME_CONFIG.smoothingSpeed;
          gameState.audioElement.volume = Math.max(
            0,
            Math.min(1, currentVolume)
          );
        } else {
          currentVolume = targetVolume;
          gameState.audioElement.volume = currentVolume;
        }

        if (gameState.isPlaying && !gameState.isPaused) {
          volumeAnimationId = requestAnimationFrame(updateVolume);
        }
      }

      // Called when player hits a note
      function onNoteHit(rating) {
        // Boost volume back towards normal
        const boost =
          rating === "PERFECT"
            ? VOLUME_CONFIG.recoveryRate * 1.5
            : rating === "GOOD"
            ? VOLUME_CONFIG.recoveryRate
            : VOLUME_CONFIG.recoveryRate * 0.7;
        targetVolume = Math.min(
          VOLUME_CONFIG.normalVolume,
          targetVolume + boost
        );
      }

      // Called when player misses a note
      function onNoteMiss() {
        // Drop volume
        targetVolume = Math.max(
          VOLUME_CONFIG.missVolume,
          targetVolume - VOLUME_CONFIG.dropAmount
        );
      }

      // Reset volume for new game
      function resetVolume() {
        targetVolume = VOLUME_CONFIG.normalVolume;
        currentVolume = VOLUME_CONFIG.normalVolume;
        if (gameState.audioElement) {
          gameState.audioElement.volume = currentVolume;
        }
      }

      // Instrument definitions
      const INSTRUMENTS = {
        guitar: { name: "Guitar", section: "Single", icon: "üé∏", lanes: 5 },
        bass: { name: "Bass", section: "DoubleBass", icon: "üé∏", lanes: 5 },
        drums: { name: "Drums", section: "Drums", icon: "ü•Å", lanes: 5 },
        keys: { name: "Keys", section: "Keyboard", icon: "üéπ", lanes: 5 },
      };

      // Game state
      let gameState = {
        isPlaying: false,
        isPaused: false,
        songCompleted: false, // Track if song finished naturally vs stopped manually
        showAllScores: false, // Toggle between song-specific and all scores view
        currentSong: null,
        instrument: "guitar",
        difficulty: "Hard",
        laneCount: 5,
        score: 0,
        combo: 0,
        maxCombo: 0,
        multiplier: 1,
        perfectCount: 0,
        goodCount: 0,
        okCount: 0,
        missedCount: 0,
        notes: [],
        activeNotes: [],
        audioElement: null,
        videoElement: null,
        audioContext: null,
        startTime: 0,
        pausedTime: 0,
        chartData: null,
        // Lyrics state
        currentLyricIndex: -1,
        currentLyricGroupKey: null,
        lyricsBuilt: false,
      };

      // ============================================
      // ANALYTICS HELPER
      // ============================================
      function trackEvent(eventName, params = {}) {
        if (typeof gtag === "function") {
          gtag("event", eventName, params);
        }
      }

      // Video elements
      const videoContainer = document.getElementById("videoContainer");
      const backgroundVideo = document.getElementById("backgroundVideo");
      const backgroundImage = document.getElementById("backgroundImage");
      const videoGlow = document.getElementById("videoGlow");

      // Pressed keys
      const pressedKeys = new Set();

      // ============================================
      // GAMEPAD SUPPORT
      // ============================================

      // Controller types
      const CONTROLLER_TYPE = {
        NONE: "none",
        SWITCH: "switch",
        TAIKO: "taiko",
        GUITAR: "guitar",
      };

      let connectedControllerType = CONTROLLER_TYPE.NONE;

      // Check if a gamepad is a Taiko controller (Vendor: 0f0d, Product: 00f0)
      function isTaikoController(gamepad) {
        const id = gamepad.id.toLowerCase();
        return (
          id.includes("0f0d") ||
          id.includes("taiko") ||
          (id.includes("vendor: 0f0d") && id.includes("product: 00f0"))
        );
      }

      // Check if a gamepad is a CRKD Guitar controller (Vendor: 057e, Product: 2009)
      function isGuitarController(gamepad) {
        const id = gamepad.id.toLowerCase();
        return (
          id.includes("crkd") ||
          id.includes("guitar") ||
          id.includes("gibson") ||
          (id.includes("vendor: 057e") && id.includes("product: 2009"))
        );
      }

      // Get max lanes supported by current controller
      function getMaxLanesForController() {
        if (connectedControllerType === CONTROLLER_TYPE.TAIKO) {
          return 4; // Taiko only has 4 inputs
        }
        return 5;
      }

      // Update lane selector based on controller
      function updateLaneSelector() {
        const maxLanes = getMaxLanesForController();
        const laneBtns = document.querySelectorAll(".lane-btn");

        laneBtns.forEach((btn) => {
          const lanes = parseInt(btn.dataset.lanes, 10);
          btn.disabled = lanes > maxLanes;

          // If current selection is now invalid, switch to max
          if (lanes > maxLanes && btn.classList.contains("selected")) {
            btn.classList.remove("selected");
            // Select the max lanes button
            document
              .querySelector(`.lane-btn[data-lanes="${maxLanes}"]`)
              ?.classList.add("selected");
            activeLaneCount = maxLanes;
            gameState.laneCount = maxLanes;
            updateGameAreaMinWidth();
            if (!gameState.isPlaying) {
              drawStaticScreen();
            }
          }
        });
      }

      // Get button mapping for Switch controller based on current lane count
      function getSwitchButtonMap() {
        if (activeLaneCount === 5) {
          return {
            6: 0,
            4: 0, // ZL/L -> lane 0
            12: 1,
            13: 1,
            14: 1,
            15: 1, // D-pad -> lane 1
            0: 2, // B -> lane 2
            1: 3, // A -> lane 3
            7: 4,
            5: 4, // ZR/R -> lane 4
          };
        } else if (activeLaneCount === 4) {
          return {
            6: 0,
            4: 0, // ZL/L -> lane 0
            12: 1,
            13: 1,
            14: 1,
            15: 1, // D-pad -> lane 1
            1: 2, // A -> lane 2
            7: 3,
            5: 3, // ZR/R -> lane 3
          };
        } else if (activeLaneCount === 3) {
          return {
            6: 0,
            4: 0, // ZL/L -> lane 0
            0: 1, // B -> lane 1 (center)
            7: 2,
            5: 2, // ZR/R -> lane 2
          };
        } else if (activeLaneCount === 2) {
          return {
            6: 0,
            4: 0, // ZL/L -> lane 0
            7: 1,
            5: 1, // ZR/R -> lane 1
          };
        } else {
          // 1 lane
          return {
            0: 0, // B -> lane 0
            1: 0, // A -> lane 0
          };
        }
      }

      // Get button mapping for Taiko controller based on current lane count
      // Taiko has 4 inputs from left to right: B6, B10, B11, B7
      function getTaikoButtonMap() {
        if (activeLaneCount === 4) {
          return {
            6: 0, // B6 -> lane 0 (leftmost)
            10: 1, // B10 -> lane 1
            11: 2, // B11 -> lane 2
            7: 3, // B7 -> lane 3 (rightmost)
          };
        } else if (activeLaneCount === 3) {
          return {
            6: 0, // B6 -> lane 0
            10: 1,
            11: 1, // B10, B11 -> lane 1 (center)
            7: 2, // B7 -> lane 2
          };
        } else if (activeLaneCount === 2) {
          return {
            6: 0,
            10: 0, // B6, B10 -> lane 0 (left)
            11: 1,
            7: 1, // B11, B7 -> lane 1 (right)
          };
        } else {
          // 1 lane
          return {
            6: 0,
            10: 0,
            11: 0,
            7: 0, // All -> lane 0
          };
        }
      }

      // Get button mapping based on controller type and lane count
      function getGamepadButtonMap() {
        if (connectedControllerType === CONTROLLER_TYPE.TAIKO) {
          return getTaikoButtonMap();
        }
        return getSwitchButtonMap();
      }

      // Gamepad button labels for display (all 5 lanes) - Switch controller
      const ALL_SWITCH_LABELS = ["L", "‚úö", "‚í∑", "‚í∂", "R"];

      // Get Switch controller labels for current lane count
      function getSwitchLabels() {
        if (activeLaneCount === 5) return ALL_SWITCH_LABELS;
        if (activeLaneCount === 4) return ["L", "‚úö", "‚í∂", "R"];
        if (activeLaneCount === 3) return ["L", "‚í∑", "R"];
        if (activeLaneCount === 2) return ["L", "R"];
        return ["‚í∑"]; // center for 1 lane
      }

      // Get Taiko controller labels for current lane count
      function getTaikoLabels() {
        if (activeLaneCount === 4) return ["‚óÄ", "‚óÅ", "‚ñ∑", "‚ñ∂"];
        if (activeLaneCount === 3) return ["‚óÄ", "‚óè", "‚ñ∂"];
        if (activeLaneCount === 2) return ["‚óÄ", "‚ñ∂"];
        return ["‚óè"]; // center for 1 lane
      }

      // Get Guitar controller labels for current lane count
      // Guitar Hero style: Green, Red, Yellow, Blue, Orange
      function getGuitarLabels() {
        if (activeLaneCount === 5) return ["üü¢", "üî¥", "üü°", "üîµ", "üü†"];
        if (activeLaneCount === 4) return ["üü¢", "üî¥", "üü°", "üîµ"];
        if (activeLaneCount === 3) return ["üü¢", "üü°", "üîµ"];
        if (activeLaneCount === 2) return ["üü¢", "üîµ"];
        return ["üü°"]; // center for 1 lane
      }

      // Get gamepad labels based on controller type
      function getGamepadLabels() {
        if (connectedControllerType === CONTROLLER_TYPE.TAIKO) {
          return getTaikoLabels();
        }
        if (connectedControllerType === CONTROLLER_TYPE.GUITAR) {
          return getGuitarLabels();
        }
        return getSwitchLabels();
      }

      let gamepadConnected = false;

      const gamepadButtonsPressed = new Set();
      let gamepadPollingId = null;

      // Guitar controller state - tracks held frets and strum
      // Fret button to lane mapping: B1=Green(0), B0=Red(1), B2=Yellow(2), B3=Blue(3), B4=Orange(4)
      const GUITAR_FRET_MAP = { 1: 0, 0: 1, 2: 2, 3: 3, 4: 4 };
      const GUITAR_STRUM_BUTTONS = [12, 13]; // Strum up (B12) and down (B13)
      const guitarFretsHeld = new Set(); // Track which frets are currently held
      let guitarStrumPressed = false; // Track strum state

      function pollGamepad() {
        const gamepads = navigator.getGamepads();
        const buttonMap = getGamepadButtonMap();
        const laneKeys = getLaneKeys();

        for (const gamepad of gamepads) {
          if (!gamepad) continue;

          // Only process input from the selected device type
          const isSelectedDevice =
            (selectedInputDevice === "drums" && isTaikoController(gamepad)) ||
            (selectedInputDevice === "guitar" && isGuitarController(gamepad)) ||
            (selectedInputDevice === "procontroller" &&
              !isTaikoController(gamepad) &&
              !isGuitarController(gamepad));

          if (!isSelectedDevice && selectedInputDevice !== "keyboard") {
            continue;
          }

          // Skip gamepad processing entirely if keyboard is selected
          if (selectedInputDevice === "keyboard") {
            continue;
          }

          // Guitar controller has special handling - frets + strum
          if (connectedControllerType === CONTROLLER_TYPE.GUITAR) {
            pollGuitarController(gamepad, laneKeys);
            continue;
          }

          // Check each mapped button
          for (const [buttonIndex, lane] of Object.entries(buttonMap)) {
            const button = gamepad.buttons[buttonIndex];
            if (!button) continue;

            const isPressed = button.pressed || button.value > 0.5;
            const key = laneKeys[lane];
            // Use compound key to track buttons per-gamepad
            const buttonKey = `${gamepad.index}:${buttonIndex}`;

            if (isPressed && !gamepadButtonsPressed.has(buttonKey)) {
              // Button just pressed
              gamepadButtonsPressed.add(buttonKey);
              pressedKeys.add(key);
              handleKeyPress(lane);
            } else if (!isPressed && gamepadButtonsPressed.has(buttonKey)) {
              // Button released
              gamepadButtonsPressed.delete(buttonKey);
              pressedKeys.delete(key);
            }
          }
        }

        gamepadPollingId = requestAnimationFrame(pollGamepad);
      }

      // Special polling for guitar controller - frets are held, strum triggers notes
      function pollGuitarController(gamepad, laneKeys) {
        // Update fret button states (don't trigger notes, just track)
        for (const [buttonIndex, lane] of Object.entries(GUITAR_FRET_MAP)) {
          const button = gamepad.buttons[Number(buttonIndex)]; // Convert to number for array access
          if (!button) continue;

          const isPressed = button.pressed || button.value > 0.5;
          const key = laneKeys[lane];

          if (isPressed) {
            guitarFretsHeld.add(buttonIndex); // Keep as string to match GUITAR_FRET_MAP keys
            pressedKeys.add(key); // For visual feedback on lane
          } else {
            guitarFretsHeld.delete(buttonIndex);
            pressedKeys.delete(key);
          }
        }

        // Check strum buttons - trigger notes for all held frets when strummed
        let strumNow = false;
        for (const strumButton of GUITAR_STRUM_BUTTONS) {
          const button = gamepad.buttons[strumButton];
          if (button && (button.pressed || button.value > 0.5)) {
            strumNow = true;
            break;
          }
        }

        // Trigger on strum press (not release)
        if (strumNow && !guitarStrumPressed) {
          guitarStrumPressed = true;

          // If no frets held, trigger based on active lane count (open strum)
          if (guitarFretsHeld.size === 0) {
            // Open strum - could trigger lane 0 or do nothing
            // For now, we'll ignore open strums
          } else {
            // Trigger notes for all held frets
            for (const buttonIndex of guitarFretsHeld) {
              const lane = GUITAR_FRET_MAP[buttonIndex];
              if (lane !== undefined && lane < activeLaneCount) {
                handleKeyPress(lane);
              }
            }
          }
        } else if (!strumNow) {
          guitarStrumPressed = false;
        }
      }

      // Detect controller type from connected gamepads
      function detectControllerType() {
        const gamepads = navigator.getGamepads();
        for (const gamepad of gamepads) {
          if (!gamepad) continue;
          if (isTaikoController(gamepad)) {
            return CONTROLLER_TYPE.TAIKO;
          }
          if (isGuitarController(gamepad)) {
            return CONTROLLER_TYPE.GUITAR;
          }
        }
        // Default to Switch if any gamepad is connected
        const hasGamepad = Array.from(gamepads).some((gp) => gp !== null);
        return hasGamepad ? CONTROLLER_TYPE.SWITCH : CONTROLLER_TYPE.NONE;
      }

      // Controller display configuration
      const CONTROLLER_DISPLAY = {
        [CONTROLLER_TYPE.NONE]: { icon: "üéÆ", name: "Pro Controller" },
        [CONTROLLER_TYPE.SWITCH]: { icon: "üéÆ", name: "Pro Controller" },
        [CONTROLLER_TYPE.TAIKO]: { icon: "ü•Å", name: "Drums" },
        [CONTROLLER_TYPE.GUITAR]: { icon: "üé∏", name: "Guitar" },
      };

      // Currently selected input device
      let selectedInputDevice = "keyboard";

      // Track connected controllers (multiple can be connected)
      const connectedDevices = {
        keyboard: true, // Keyboard is always available
        drums: false,
        guitar: false,
        procontroller: false,
      };

      // Map controller types to device names
      const CONTROLLER_TO_DEVICE = {
        [CONTROLLER_TYPE.TAIKO]: "drums",
        [CONTROLLER_TYPE.GUITAR]: "guitar",
        [CONTROLLER_TYPE.SWITCH]: "procontroller",
      };

      // Update input device selector UI
      function updateInputDeviceSelector(justConnectedDevice = null) {
        const deviceButtons = document.querySelectorAll(".input-device-btn");

        deviceButtons.forEach((btn) => {
          const device = btn.dataset.device;

          // Update connected state
          if (connectedDevices[device]) {
            btn.disabled = false;
            btn.classList.add("connected");
            btn.querySelector(".device-status").textContent =
              device === "keyboard" ? "Ready" : "Connected";
          } else {
            btn.disabled = true;
            btn.classList.remove("connected");
            btn.querySelector(".device-status").textContent = "Disconnected";
          }

          // Update selected state
          if (device === selectedInputDevice) {
            btn.classList.add("selected");
            btn.querySelector(".device-status").textContent = "Selected";
          } else {
            btn.classList.remove("selected");
          }

          // Pulse animation for just connected device
          if (justConnectedDevice === device) {
            btn.classList.remove("just-connected");
            void btn.offsetWidth; // Force reflow
            btn.classList.add("just-connected");
          }
        });
      }

      // Select input device
      function selectInputDevice(device) {
        if (!connectedDevices[device]) return;
        selectedInputDevice = device;

        // Track input device selection
        trackEvent("select_input_device", {
          device: device,
        });

        // Update the connectedControllerType to match selection
        if (device === "keyboard") {
          connectedControllerType = CONTROLLER_TYPE.NONE;
        } else if (device === "drums") {
          connectedControllerType = CONTROLLER_TYPE.TAIKO;
        } else if (device === "guitar") {
          connectedControllerType = CONTROLLER_TYPE.GUITAR;
        } else if (device === "procontroller") {
          connectedControllerType = CONTROLLER_TYPE.SWITCH;
        }

        // Update lane selector (drums limited to 4 lanes)
        updateLaneSelector();
        updateInputDeviceSelector();
      }

      // Initialize input device selector click handlers
      function initInputDeviceSelector() {
        const deviceButtons = document.querySelectorAll(".input-device-btn");
        deviceButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            const device = btn.dataset.device;
            selectInputDevice(device);
          });
        });
      }

      // Update connected devices when gamepads connect/disconnect
      function updateConnectedDevices() {
        const gamepads = navigator.getGamepads();

        // Reset all gamepad devices
        connectedDevices.drums = false;
        connectedDevices.guitar = false;
        connectedDevices.procontroller = false;

        // Check each connected gamepad
        for (const gamepad of gamepads) {
          if (!gamepad) continue;

          if (isTaikoController(gamepad)) {
            connectedDevices.drums = true;
          } else if (isGuitarController(gamepad)) {
            connectedDevices.guitar = true;
          } else {
            // Any other gamepad is treated as Pro Controller
            connectedDevices.procontroller = true;
          }
        }

        // If selected device was disconnected, fall back to keyboard
        if (!connectedDevices[selectedInputDevice]) {
          selectedInputDevice = "keyboard";
        }
      }

      // Start polling when a gamepad is connected
      window.addEventListener("gamepadconnected", (e) => {
        console.log("Gamepad connected:", e.gamepad.id);
        gamepadConnected = true;

        // Detect controller type for this specific gamepad
        let justConnectedDevice = null;
        if (isTaikoController(e.gamepad)) {
          console.log("Taiko Controller detected - limiting to 4 lanes");
          justConnectedDevice = "drums";
        } else if (isGuitarController(e.gamepad)) {
          console.log("Guitar Controller detected - 5 lanes, strum to play");
          // Clear guitar state
          guitarFretsHeld.clear();
          guitarStrumPressed = false;
          justConnectedDevice = "guitar";
        } else {
          justConnectedDevice = "procontroller";
        }

        // Track controller connection
        trackEvent("controller_connected", {
          controller_type: justConnectedDevice,
          controller_id: e.gamepad.id,
        });

        // Update all connected devices
        updateConnectedDevices();

        // Update lane selector (disable 5 lanes for Taiko if selected)
        updateLaneSelector();

        // Update input device selector UI
        updateInputDeviceSelector(justConnectedDevice);

        if (!gamepadPollingId) {
          pollGamepad();
        }
      });

      window.addEventListener("gamepaddisconnected", (e) => {
        console.log("Gamepad disconnected:", e.gamepad.id);
        // Only clear button states from the disconnected gamepad
        const disconnectedIndex = e.gamepad.index;
        const keysToDelete = [];
        for (const buttonKey of gamepadButtonsPressed) {
          if (buttonKey.startsWith(`${disconnectedIndex}:`)) {
            keysToDelete.push(buttonKey);
          }
        }
        keysToDelete.forEach((key) => gamepadButtonsPressed.delete(key));

        // Clear guitar state only if the disconnected gamepad is a guitar
        if (isGuitarController(e.gamepad)) {
          guitarFretsHeld.clear();
          guitarStrumPressed = false;
        }

        // Update connected devices
        updateConnectedDevices();

        // Re-detect controller type based on selected device
        if (selectedInputDevice === "keyboard") {
          connectedControllerType = CONTROLLER_TYPE.NONE;
        } else if (selectedInputDevice === "drums" && connectedDevices.drums) {
          connectedControllerType = CONTROLLER_TYPE.TAIKO;
        } else if (
          selectedInputDevice === "guitar" &&
          connectedDevices.guitar
        ) {
          connectedControllerType = CONTROLLER_TYPE.GUITAR;
        } else if (
          selectedInputDevice === "procontroller" &&
          connectedDevices.procontroller
        ) {
          connectedControllerType = CONTROLLER_TYPE.SWITCH;
        } else {
          connectedControllerType = CONTROLLER_TYPE.NONE;
        }

        // Stop polling if no gamepads connected
        const gamepads = navigator.getGamepads();
        const hasGamepad = Array.from(gamepads).some((gp) => gp !== null);
        if (!hasGamepad) {
          gamepadConnected = false;
          connectedControllerType = CONTROLLER_TYPE.NONE;
          if (gamepadPollingId) {
            cancelAnimationFrame(gamepadPollingId);
            gamepadPollingId = null;
          }
        }

        // Update lane selector (re-enable 5 lanes if no Taiko)
        updateLaneSelector();

        // Update input device selector UI
        updateInputDeviceSelector();
      });

      // Check for already-connected gamepads on page load
      function checkExistingGamepads() {
        const gamepads = navigator.getGamepads();
        const hasGamepad = Array.from(gamepads).some((gp) => gp !== null);
        if (hasGamepad && !gamepadPollingId) {
          gamepadConnected = true;
          updateConnectedDevices();
          updateLaneSelector();
          updateInputDeviceSelector();
          pollGamepad();
        }
      }

      // Canvas setup
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");

      // ============================================
      // CHART PARSER
      // ============================================

      class ChartParser {
        constructor(chartContent) {
          this.content = chartContent
            .replace(/^\uFEFF/, "")
            .replace(/\r\n/g, "\n");
          this.sections = {};
          this.songData = {};
          this.resolution = 192;
          this.bpmEvents = [];
          this.parse();
        }

        parse() {
          this.parseSections();
          this.parseSongSection();
          this.parseSyncTrack();
          this.parseEvents();
        }

        parseSections() {
          const lines = this.content.split("\n");
          let currentSection = null;
          let currentContent = [];
          let braceDepth = 0;

          for (const line of lines) {
            const sectionMatch = line.match(/^\[([^\]]+)\]$/);
            if (sectionMatch && braceDepth === 0) {
              if (currentSection) {
                this.sections[currentSection] = currentContent.join("\n");
              }
              currentSection = sectionMatch[1];
              currentContent = [];
              continue;
            }

            if (line.trim() === "{") {
              braceDepth++;
              continue;
            }
            if (line.trim() === "}") {
              braceDepth--;
              if (braceDepth === 0 && currentSection) {
                this.sections[currentSection] = currentContent.join("\n");
                currentSection = null;
                currentContent = [];
              }
              continue;
            }

            if (currentSection && braceDepth > 0) {
              currentContent.push(line);
            }
          }
        }

        parseSongSection() {
          const content = this.sections["Song"] || "";
          const lines = content.split("\n");
          for (const line of lines) {
            const match = line.match(/^\s*(\w+)\s*=\s*(.+)$/);
            if (match) {
              let value = match[2].trim();
              if (value.startsWith('"') && value.endsWith('"')) {
                value = value.slice(1, -1);
              }
              this.songData[match[1]] = value;
            }
          }
          if (this.songData.Resolution) {
            this.resolution = parseInt(this.songData.Resolution, 10);
          }
        }

        parseSyncTrack() {
          const content = this.sections["SyncTrack"] || "";
          const lines = content.split("\n");

          for (const line of lines) {
            const match = line.match(/^\s*(\d+)\s*=\s*(\w+)\s+(.+)$/);
            if (match) {
              const tick = parseInt(match[1], 10);
              const type = match[2];
              const value = match[3].trim();

              if (type === "B") {
                const bpm = parseInt(value, 10) / 1000;
                this.bpmEvents.push({ tick, bpm });
              }
            }
          }

          if (this.bpmEvents.length === 0) {
            this.bpmEvents.push({ tick: 0, bpm: 120 });
          }
          this.bpmEvents.sort((a, b) => a.tick - b.tick);
        }

        parseEvents() {
          this.lyrics = [];
          this.sectionMarkers = [];
          this.lyricGroups = []; // Groups of phrases to display together

          const content = this.sections["Events"] || "";
          const lines = content.split("\n");

          let currentPhrase = { words: [], startTick: 0 };

          for (const line of lines) {
            const match = line.match(/^\s*(\d+)\s*=\s*E\s+"(.+)"$/);
            if (!match) continue;

            const tick = parseInt(match[1], 10);
            const event = match[2];

            if (event.startsWith("section ")) {
              this.sectionMarkers.push({
                tick,
                time: this.tickToMs(tick),
                name: event.slice(8),
              });
            } else if (event === "phrase_start") {
              // If previous phrase has words but no phrase_end was encountered,
              // save it now before starting a new phrase
              if (currentPhrase.words.length > 0) {
                const lastWord =
                  currentPhrase.words[currentPhrase.words.length - 1];
                currentPhrase.endTick = lastWord.tick;
                currentPhrase.startTime = this.tickToMs(
                  currentPhrase.startTick
                );
                currentPhrase.endTime = this.tickToMs(currentPhrase.endTick);
                this.lyrics.push(currentPhrase);
              }
              currentPhrase = { words: [], startTick: tick };
            } else if (event === "phrase_end") {
              if (currentPhrase.words.length > 0) {
                currentPhrase.endTick = tick;
                currentPhrase.startTime = this.tickToMs(
                  currentPhrase.startTick
                );
                currentPhrase.endTime = this.tickToMs(tick);
                this.lyrics.push(currentPhrase);
              }
              // Reset currentPhrase after pushing to avoid duplicates
              currentPhrase = { words: [], startTick: 0 };
            } else if (event.startsWith("lyric ")) {
              let text = event.slice(6);
              // Handle special characters in lyrics
              text = text.replace(/=(?![^<]*>)/g, ""); // Remove = signs used for melisma, but preserve = inside tags (color, size, etc.)
              text = text.replace(/-$/, ""); // Remove trailing hyphen (syllable continues)
              const continuesWord = event.slice(6).endsWith("-");
              currentPhrase.words.push({
                tick,
                time: this.tickToMs(tick),
                text,
                continuesWord,
              });
            }
          }

          // Handle any remaining phrase that wasn't closed with phrase_end
          if (currentPhrase.words.length > 0) {
            const lastWord =
              currentPhrase.words[currentPhrase.words.length - 1];
            currentPhrase.endTick = lastWord.tick;
            currentPhrase.startTime = this.tickToMs(currentPhrase.startTick);
            currentPhrase.endTime = this.tickToMs(currentPhrase.endTick);
            this.lyrics.push(currentPhrase);
          }

          // Sort by time
          this.lyrics.sort((a, b) => a.startTime - b.startTime);
          this.sectionMarkers.sort((a, b) => a.time - b.time);

          // Group phrases into display groups (4 phrases at a time)
          const PHRASES_PER_GROUP = 4;
          for (let i = 0; i < this.lyrics.length; i += PHRASES_PER_GROUP) {
            const groupPhrases = this.lyrics.slice(i, i + PHRASES_PER_GROUP);
            if (groupPhrases.length > 0) {
              this.lyricGroups.push({
                phrases: groupPhrases,
                startIndex: i,
                endIndex: i + groupPhrases.length - 1,
                startTime: groupPhrases[0].startTime,
                endTime: groupPhrases[groupPhrases.length - 1].endTime,
              });
            }
          }
        }

        hasLyrics() {
          return this.lyrics && this.lyrics.length > 0;
        }

        getLyricPhraseAt(timeMs) {
          for (let i = 0; i < this.lyrics.length; i++) {
            const phrase = this.lyrics[i];
            // Show phrase slightly before it starts and until it ends
            if (
              timeMs >= phrase.startTime - 500 &&
              timeMs <= phrase.endTime + 200
            ) {
              return { phrase, index: i };
            }
          }
          return null;
        }

        getNextLyricPhrase(currentIndex) {
          if (currentIndex >= 0 && currentIndex < this.lyrics.length - 1) {
            return this.lyrics[currentIndex + 1];
          }
          return null;
        }

        getSectionAt(timeMs) {
          let currentSection = null;
          for (const section of this.sectionMarkers) {
            if (section.time <= timeMs) {
              currentSection = section;
            } else {
              break;
            }
          }
          return currentSection;
        }

        getAvailableInstruments() {
          const available = {};
          const difficulties = ["Easy", "Medium", "Hard", "Expert"];

          for (const [key, inst] of Object.entries(INSTRUMENTS)) {
            const diffs = [];
            for (const diff of difficulties) {
              if (this.sections[`${diff}${inst.section}`]) {
                diffs.push(diff);
              }
            }
            if (diffs.length > 0) {
              available[key] = diffs;
            }
          }
          return available;
        }

        getAvailableTracks(instrument = "guitar") {
          const inst = INSTRUMENTS[instrument];
          if (!inst) return [];

          const tracks = [];
          const difficulties = ["Easy", "Medium", "Hard", "Expert"];
          for (const diff of difficulties) {
            if (this.sections[`${diff}${inst.section}`]) {
              tracks.push(diff);
            }
          }
          return tracks;
        }

        getNotes(difficulty, instrument = "guitar") {
          const inst = INSTRUMENTS[instrument];
          if (!inst) return [];

          const sectionName = `${difficulty}${inst.section}`;
          const content = this.sections[sectionName] || "";
          const lines = content.split("\n");
          const notes = [];

          for (const line of lines) {
            const match = line.match(/^\s*(\d+)\s*=\s*N\s+(\d+)\s+(\d+)\s*$/);
            if (match) {
              const tick = parseInt(match[1], 10);
              const lane = parseInt(match[2], 10);
              const duration = parseInt(match[3], 10);

              // Only process frets 0-4 (skip modifiers like 5, 6, 7)
              if (lane >= 0 && lane <= 4) {
                notes.push({
                  tick,
                  lane,
                  duration,
                  time: this.tickToMs(tick),
                  durationMs:
                    this.tickToMs(tick + duration) - this.tickToMs(tick),
                });
              }
            }
          }

          return notes.sort((a, b) => a.time - b.time);
        }

        tickToMs(tick) {
          let ms = 0;
          let lastTick = 0;
          let lastBpm = this.bpmEvents[0]?.bpm || 120;

          for (const event of this.bpmEvents) {
            if (event.tick > tick) break;
            const tickDelta = event.tick - lastTick;
            const msPerTick = 60000 / lastBpm / this.resolution;
            ms += tickDelta * msPerTick;
            lastTick = event.tick;
            lastBpm = event.bpm;
          }

          const remainingTicks = tick - lastTick;
          const msPerTick = 60000 / lastBpm / this.resolution;
          ms += remainingTicks * msPerTick;

          return ms;
        }
      }

      // ============================================
      // MIDI PARSER (for Rock Band/Harmonix style songs)
      // ============================================

      class MidiParser {
        constructor(arrayBuffer) {
          this.data = new DataView(arrayBuffer);
          this.pos = 0;
          this.tracks = {};
          this.resolution = 480;
          this.bpmEvents = [];
          this.songData = {};
          // MIDI files don't typically contain lyrics in standard format
          this.lyrics = [];
          this.lyricGroups = [];
          this.sectionMarkers = [];
          this.parse();
        }

        hasLyrics() {
          return false;
        }

        readBytes(n) {
          const bytes = [];
          for (let i = 0; i < n; i++) {
            bytes.push(this.data.getUint8(this.pos++));
          }
          return bytes;
        }

        readInt(n) {
          let val = 0;
          for (let i = 0; i < n; i++) {
            val = (val << 8) | this.data.getUint8(this.pos++);
          }
          return val;
        }

        readVarLen() {
          let val = 0;
          let byte;
          do {
            byte = this.data.getUint8(this.pos++);
            val = (val << 7) | (byte & 0x7f);
          } while (byte & 0x80);
          return val;
        }

        readString(len) {
          let str = "";
          for (let i = 0; i < len; i++) {
            str += String.fromCharCode(this.data.getUint8(this.pos++));
          }
          return str;
        }

        parse() {
          // Read header
          const headerChunk = this.readString(4);
          if (headerChunk !== "MThd") {
            throw new Error("Invalid MIDI file");
          }
          const headerLen = this.readInt(4);
          const format = this.readInt(2);
          const numTracks = this.readInt(2);
          this.resolution = this.readInt(2);

          // Read tracks
          for (let t = 0; t < numTracks; t++) {
            const trackChunk = this.readString(4);
            if (trackChunk !== "MTrk") continue;
            const trackLen = this.readInt(4);
            const trackEnd = this.pos + trackLen;

            let trackName = "";
            let runningStatus = 0;
            let tick = 0;
            const notes = []; // Note on events waiting for note off
            const trackNotes = [];

            while (this.pos < trackEnd) {
              const delta = this.readVarLen();
              tick += delta;

              let status = this.data.getUint8(this.pos);
              if (status < 0x80) {
                // Running status
                status = runningStatus;
              } else {
                this.pos++;
                runningStatus = status;
              }

              const type = status & 0xf0;
              const channel = status & 0x0f;

              if (type === 0x90) {
                // Note on
                const note = this.data.getUint8(this.pos++);
                const velocity = this.data.getUint8(this.pos++);
                if (velocity > 0) {
                  notes.push({ tick, note, velocity });
                } else {
                  // Note off (velocity 0)
                  const idx = notes.findIndex((n) => n.note === note);
                  if (idx >= 0) {
                    const startNote = notes.splice(idx, 1)[0];
                    trackNotes.push({
                      tick: startNote.tick,
                      note: startNote.note,
                      duration: tick - startNote.tick,
                    });
                  }
                }
              } else if (type === 0x80) {
                // Note off
                const note = this.data.getUint8(this.pos++);
                this.pos++; // velocity
                const idx = notes.findIndex((n) => n.note === note);
                if (idx >= 0) {
                  const startNote = notes.splice(idx, 1)[0];
                  trackNotes.push({
                    tick: startNote.tick,
                    note: startNote.note,
                    duration: tick - startNote.tick,
                  });
                }
              } else if (type === 0xa0) {
                // Aftertouch
                this.pos += 2;
              } else if (type === 0xb0) {
                // Control change
                this.pos += 2;
              } else if (type === 0xc0) {
                // Program change
                this.pos++;
              } else if (type === 0xd0) {
                // Channel pressure
                this.pos++;
              } else if (type === 0xe0) {
                // Pitch bend
                this.pos += 2;
              } else if (status === 0xff) {
                // Meta event
                const metaType = this.data.getUint8(this.pos++);
                const metaLen = this.readVarLen();

                if (metaType === 0x03) {
                  // Track name
                  trackName = this.readString(metaLen);
                } else if (metaType === 0x51) {
                  // Tempo
                  const tempo = this.readInt(3);
                  const bpm = 60000000 / tempo;
                  this.bpmEvents.push({ tick, bpm });
                } else {
                  this.pos += metaLen;
                }
              } else if (status === 0xf0 || status === 0xf7) {
                // SysEx
                const len = this.readVarLen();
                this.pos += len;
              }
            }

            if (trackName && trackNotes.length > 0) {
              this.tracks[trackName] = trackNotes;
            }
          }

          if (this.bpmEvents.length === 0) {
            this.bpmEvents.push({ tick: 0, bpm: 120 });
          }
          this.bpmEvents.sort((a, b) => a.tick - b.tick);
        }

        // Rock Band MIDI note mappings
        static GUITAR_NOTES = {
          Expert: { base: 96, lanes: [0, 1, 2, 3, 4] },
          Hard: { base: 84, lanes: [0, 1, 2, 3, 4] },
          Medium: { base: 72, lanes: [0, 1, 2, 3, 4] },
          Easy: { base: 60, lanes: [0, 1, 2, 3, 4] },
        };

        static DRUMS_NOTES = {
          Expert: { base: 96, lanes: [0, 1, 2, 3, 4] },
          Hard: { base: 84, lanes: [0, 1, 2, 3, 4] },
          Medium: { base: 72, lanes: [0, 1, 2, 3, 4] },
          Easy: { base: 60, lanes: [0, 1, 2, 3, 4] },
        };

        getAvailableInstruments() {
          const available = {};
          const trackMap = {
            guitar: ["PART GUITAR", "T1 GEMS"],
            bass: ["PART BASS", "PART RHYTHM"],
            drums: ["PART DRUMS"],
            keys: ["PART KEYS", "PART KEYBOARD", "PART REAL_KEYS_X"],
          };

          for (const [inst, trackNames] of Object.entries(trackMap)) {
            for (const name of trackNames) {
              if (this.tracks[name]) {
                const notes = this.tracks[name];
                const diffs = [];

                // Check which difficulties have notes
                for (const diff of ["Easy", "Medium", "Hard", "Expert"]) {
                  const mapping = MidiParser.GUITAR_NOTES[diff];
                  const hasNotes = notes.some(
                    (n) => n.note >= mapping.base && n.note < mapping.base + 5
                  );
                  if (hasNotes) diffs.push(diff);
                }

                if (diffs.length > 0) {
                  available[inst] = diffs;
                }
                break;
              }
            }
          }

          return available;
        }

        getAvailableTracks(instrument = "guitar") {
          const available = this.getAvailableInstruments();
          return available[instrument] || [];
        }

        getNotes(difficulty, instrument = "guitar") {
          const trackMap = {
            guitar: ["PART GUITAR", "T1 GEMS"],
            bass: ["PART BASS", "PART RHYTHM"],
            drums: ["PART DRUMS"],
            keys: ["PART KEYS", "PART KEYBOARD", "PART REAL_KEYS_X"],
          };

          const trackNames = trackMap[instrument] || [];
          let trackNotes = null;

          for (const name of trackNames) {
            if (this.tracks[name]) {
              trackNotes = this.tracks[name];
              break;
            }
          }

          if (!trackNotes) return [];

          const mapping =
            instrument === "drums"
              ? MidiParser.DRUMS_NOTES[difficulty]
              : MidiParser.GUITAR_NOTES[difficulty];

          if (!mapping) return [];

          const notes = [];
          for (const n of trackNotes) {
            const lane = n.note - mapping.base;
            if (lane >= 0 && lane <= 4) {
              notes.push({
                tick: n.tick,
                lane,
                duration: n.duration,
                time: this.tickToMs(n.tick),
                durationMs:
                  this.tickToMs(n.tick + n.duration) - this.tickToMs(n.tick),
              });
            }
          }

          return notes.sort((a, b) => a.time - b.time);
        }

        tickToMs(tick) {
          let ms = 0;
          let lastTick = 0;
          let lastBpm = this.bpmEvents[0]?.bpm || 120;

          for (const event of this.bpmEvents) {
            if (event.tick > tick) break;
            const tickDelta = event.tick - lastTick;
            const msPerTick = 60000 / lastBpm / this.resolution;
            ms += tickDelta * msPerTick;
            lastTick = event.tick;
            lastBpm = event.bpm;
          }

          const remainingTicks = tick - lastTick;
          const msPerTick = 60000 / lastBpm / this.resolution;
          ms += remainingTicks * msPerTick;

          return ms;
        }
      }

      // ============================================
      // SONG LOADING & SEARCH
      // ============================================

      // Store all songs for filtering
      let allSongs = [];

      function parseIni(content) {
        const result = {};
        // Remove BOM if present and normalize line endings
        let normalizedContent = content;
        if (normalizedContent.charCodeAt(0) === 0xfeff) {
          normalizedContent = normalizedContent.slice(1);
        }
        normalizedContent = normalizedContent
          .replace(/\r\n/g, "\n")
          .replace(/\r/g, "\n");
        const lines = normalizedContent.split("\n");

        for (const line of lines) {
          const match = line.match(/^\s*(\w+)\s*=\s*(.+)$/);
          if (match) {
            result[match[1].toLowerCase()] = match[2].trim();
          }
        }
        return result;
      }

      // Convert Unity rich text tags to HTML
      function unityRichTextToHtml(text) {
        if (!text) return text;
        // Convert <color=#RRGGBB>text</color> to <span style="color: #RRGGBB">text</span>
        // Convert <size=N>text</size> to <span style="font-size: Npx">text</span>
        // Note: <b>, </b>, <i>, </i> are already valid HTML
        return text
          .replace(/<color=([^>]+)>/gi, (match, color) => {
            // Sanitize color value - only allow safe CSS color formats
            const safeColor = color.replace(/[^a-zA-Z0-9#(),.\s%-]/g, "");
            if (
              /^#[0-9a-fA-F]{3,8}$/.test(safeColor) ||
              /^[a-zA-Z]+$/.test(safeColor) ||
              /^rgba?\([0-9,.\s%]+\)$/.test(safeColor) ||
              /^hsla?\([0-9,.\s%]+\)$/.test(safeColor)
            ) {
              return `<span style="color: ${safeColor}">`;
            }
            return "<span>";
          })
          .replace(/<\/color>/gi, "</span>")
          .replace(/<size=(\d+)>/gi, '<span style="font-size: $1px">')
          .replace(/<\/size>/gi, "</span>");
      }

      // Escape HTML entities to prevent XSS
      function escapeHtml(text) {
        if (!text) return text;
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Strip Unity rich text tags for plain text use (search, data attributes)
      function stripRichText(text) {
        if (!text) return text;
        return text
          .replace(/<\/?color[^>]*>/gi, "")
          .replace(/<\/?size[^>]*>/gi, "")
          .replace(/<\/?b>/gi, "")
          .replace(/<\/?i>/gi, "");
      }

      // Check if text contains Unity rich text tags
      function hasRichText(text) {
        if (!text) return false;
        return /<(color|size|b|i)[^>]*>/i.test(text);
      }

      function addSongToList(song) {
        // Track song loaded
        trackEvent("song_loaded", {
          song_title: song.name || song.title,
          song_artist: song.artist,
          has_video: !!song.videoUrl,
          file_type: song.fileType || "folder",
        });

        // Hide empty state when first song is added
        const emptyState = document.getElementById("emptyState");
        if (emptyState) {
          emptyState.classList.add("hidden");
        }

        // Store song in array for filtering
        allSongs.push(song);

        // Create and append the song element
        const item = createSongElement(song);
        document.getElementById("songList").appendChild(item);

        // Update song count and filter options
        updateSongCount();
        updateFilterOptions();
      }

      // Format milliseconds to mm:ss
      function formatDuration(ms) {
        if (!ms || ms <= 0) return null;
        const totalSeconds = Math.floor(ms / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, "0")}`;
      }

      // Create difficulty dots (1-6 scale)
      function createDifficultyDots(difficulty) {
        if (difficulty === null || difficulty === undefined || difficulty < 0)
          return "";
        const maxDots = 6;
        const level = Math.min(Math.max(0, difficulty), maxDots);
        let dots = "";
        for (let i = 0; i < maxDots; i++) {
          if (i < level) {
            dots += `<span class="dot filled filled-${level}"></span>`;
          } else {
            dots += `<span class="dot"></span>`;
          }
        }
        return `<div class="song-difficulty" title="Difficulty: ${level}/6">${dots}</div>`;
      }

      function createSongElement(song) {
        const item = document.createElement("div");
        item.className = "song-item";
        item.dataset.songName = song.name.toLowerCase();
        item.dataset.songArtist = song.artist.toLowerCase();

        // Add loading phrase as tooltip data attribute
        if (song.loadingPhrase) {
          // Strip HTML tags for the tooltip
          const plainPhrase = song.loadingPhrase.replace(/<[^>]*>/g, "");
          item.dataset.loadingPhrase = plainPhrase;
        }

        const videoBadge = song.videoUrl
          ? '<span class="video-badge">üé¨ Video</span>'
          : "";
        // Escape user-provided values to prevent XSS
        const safeName = escapeHtml(song.name);
        const safeArtist = escapeHtml(song.artist);
        // Album URL is already properly encoded from server - escape quotes for HTML attribute safety
        const safeAlbumUrl = (song.albumArtUrl || "").replace(/"/g, "&quot;");

        // Format duration and difficulty
        const duration = formatDuration(song.songLength);
        const durationHtml = duration
          ? `<span class="song-duration">${duration}</span>`
          : "";
        const difficultyHtml = createDifficultyDots(song.difficulty);

        item.innerHTML = `
        <img src="${safeAlbumUrl}" alt="Album" onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23333%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2250%22 text-anchor=%22middle%22 dy=%220.35em%22 fill=%22%23666%22 font-size=%2240%22>‚ô™</text></svg>'">
        <div class="song-info">
          <div class="song-title">${safeName}${videoBadge}</div>
          <div class="song-artist">${safeArtist}</div>
        </div>
        <div class="song-meta">
          ${difficultyHtml}
          ${durationHtml}
        </div>
      `;

        // Add audio preview on hover
        setupAudioPreview(item, song);

        item.addEventListener("click", () => selectSong(song, item));
        return item;
      }

      // Audio preview state
      let previewAudio = null;
      let previewTimeout = null;
      let previewFadeInterval = null;
      let previewIsFromSelection = false; // Track if preview was started by song selection
      let backgroundPreviewIsFromSelection = false; // Track if background preview is from selection

      function setupAudioPreview(element, song) {
        let hoverTimeout = null;
        let isHoveringBackground = false;

        element.addEventListener("mouseenter", () => {
          // Don't preview audio if game is playing or if a selection preview is active
          if (gameState.isPlaying || previewIsFromSelection) return;

          // Delay before starting preview (300ms)
          hoverTimeout = setTimeout(() => {
            startAudioPreview(song, false);
          }, 300);

          // Show background preview immediately (no delay) - always allowed even when song selected
          if (!gameState.isPlaying) {
            isHoveringBackground = true;
            showBackgroundPreview(song, false);
          }
        });

        element.addEventListener("mouseleave", () => {
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          // Only stop if this was a hover preview, not a selection preview
          if (!previewIsFromSelection) {
            stopAudioPreview();
          }
          // Restore background if we were showing a hover preview
          if (isHoveringBackground) {
            isHoveringBackground = false;
            restoreBackground();
          }
        });
      }

      // Show background preview for a song (uses background image or album art as fallback)
      function showBackgroundPreview(song, fromSelection = false) {
        backgroundPreviewIsFromSelection = fromSelection;

        // Use background image, or fall back to album art if no video
        let previewUrl = song.backgroundUrl;
        if (!previewUrl && !song.videoUrl) {
          previewUrl = song.albumArtUrl;
        }

        if (previewUrl) {
          backgroundImage.src = previewUrl;
          backgroundImage.classList.add("active");
          videoContainer.classList.add("active");
        } else if (fromSelection) {
          // Selection with no background and no album art - hide it
          backgroundImage.src = "";
          backgroundImage.classList.remove("active");
          if (!song.videoUrl) {
            videoContainer.classList.remove("active");
          }
        }
      }

      // Restore background to the currently selected song (or hide if none)
      function restoreBackground() {
        backgroundPreviewIsFromSelection = false;

        if (gameState.currentSong) {
          // Restore selected song's background (use album art as fallback if no video)
          let bgUrl = gameState.currentSong.backgroundUrl;
          if (!bgUrl && !gameState.currentSong.videoUrl) {
            bgUrl = gameState.currentSong.albumArtUrl;
          }

          if (bgUrl) {
            backgroundImage.src = bgUrl;
            backgroundImage.classList.add("active");
            videoContainer.classList.add("active");
          } else {
            backgroundImage.src = "";
            backgroundImage.classList.remove("active");
            if (!gameState.currentSong.videoUrl) {
              videoContainer.classList.remove("active");
            }
          }
        } else {
          // No song selected, hide background
          backgroundImage.src = "";
          backgroundImage.classList.remove("active");
          videoContainer.classList.remove("active");
        }
      }

      function startAudioPreview(song, fromSelection = false) {
        // Stop any existing preview
        stopAudioPreview(true);

        // Track whether this preview is from song selection
        previewIsFromSelection = fromSelection;

        try {
          previewAudio = new Audio(song.audioUrl);
          previewAudio.volume = 0;

          // Calculate preview start time, or middle of song if no preview time specified
          let startTime;
          if (song.previewStartTime) {
            startTime = song.previewStartTime / 1000;
          } else if (song.songLength) {
            // No preview time - start at ~40% into the song (usually past intro)
            startTime = (song.songLength * 0.4) / 1000;
          } else {
            startTime = 0;
          }

          const fadeInAndPlay = () => {
            if (!previewAudio) return;
            // Fade in
            let vol = 0;
            previewFadeInterval = setInterval(() => {
              vol = Math.min(vol + 0.05, 0.3); // Max 30% volume
              if (previewAudio) previewAudio.volume = vol;
              if (vol >= 0.3) clearInterval(previewFadeInterval);
            }, 30);

            // Stop after 10 seconds
            previewTimeout = setTimeout(() => {
              stopAudioPreview();
            }, 10000);
          };

          // For seeking to work reliably, we need to:
          // 1. Wait for canplay (enough data buffered)
          // 2. Seek to position
          // 3. Wait for seeked event, then play
          const startFromPosition = () => {
            if (!previewAudio) return;

            // Clamp startTime to valid range
            const seekTo = Math.min(
              startTime,
              Math.max(0, (previewAudio.duration || 9999) - 1)
            );

            if (seekTo > 0) {
              // Need to seek - wait for seeked event before playing
              previewAudio.addEventListener(
                "seeked",
                () => {
                  if (!previewAudio) return;
                  previewAudio
                    .play()
                    .then(fadeInAndPlay)
                    .catch(() => {});
                },
                { once: true }
              );
              previewAudio.currentTime = seekTo;
            } else {
              // No seek needed, play immediately
              previewAudio
                .play()
                .then(fadeInAndPlay)
                .catch(() => {});
            }
          };

          // Wait for canplay (more data buffered than loadedmetadata)
          if (previewAudio.readyState >= 3) {
            startFromPosition();
          } else {
            previewAudio.addEventListener("canplay", startFromPosition, {
              once: true,
            });
          }
        } catch (e) {
          // Ignore errors
        }
      }

      function stopAudioPreview(immediate = false) {
        // Reset selection flag
        previewIsFromSelection = false;

        if (previewFadeInterval) {
          clearInterval(previewFadeInterval);
          previewFadeInterval = null;
        }
        if (previewTimeout) {
          clearTimeout(previewTimeout);
          previewTimeout = null;
        }

        if (previewAudio) {
          if (immediate) {
            previewAudio.pause();
            previewAudio = null;
          } else {
            // Fade out
            const audio = previewAudio;
            previewAudio = null;
            let vol = audio.volume;
            const fadeOut = setInterval(() => {
              vol = Math.max(vol - 0.05, 0);
              audio.volume = vol;
              if (vol <= 0) {
                clearInterval(fadeOut);
                audio.pause();
              }
            }, 20);
          }
        }
      }

      function updateSongCount(filteredCount = null) {
        const countEl = document.getElementById("songCount");
        if (allSongs.length === 0) {
          countEl.textContent = "";
        } else if (
          filteredCount !== null &&
          filteredCount !== allSongs.length
        ) {
          countEl.textContent = `Showing ${filteredCount} of ${allSongs.length} songs`;
        } else {
          countEl.textContent = `${allSongs.length} songs`;
        }
      }

      // Debounce timer for search tracking
      let searchTrackingTimeout = null;

      function filterAndSortSongs() {
        const songList = document.getElementById("songList");
        const searchTerm = document
          .getElementById("searchInput")
          .value.toLowerCase()
          .trim();
        const decadeFilter = document.getElementById("decadeFilter").value;
        const videoFilter = document.getElementById("videoFilter").checked;
        const sortBy = document.getElementById("sortSelect").value;

        // Track search with debounce (only track after user stops typing)
        if (searchTerm) {
          clearTimeout(searchTrackingTimeout);
          searchTrackingTimeout = setTimeout(() => {
            trackEvent("search_songs", {
              search_term: searchTerm,
            });
          }, 1000);
        }

        // Update clear filters button visibility
        updateClearFiltersVisibility();

        // Clear current list
        songList.innerHTML = "";

        // Filter songs
        let filtered = allSongs.filter((song) => {
          // Search term filter
          if (searchTerm) {
            const nameMatch = song.name.toLowerCase().includes(searchTerm);
            const artistMatch = song.artist.toLowerCase().includes(searchTerm);
            const albumMatch =
              song.album && song.album.toLowerCase().includes(searchTerm);
            if (!nameMatch && !artistMatch && !albumMatch) return false;
          }

          // Decade filter (e.g., "1990" matches years 1990-1999)
          if (decadeFilter && song.year) {
            const songDecade = Math.floor(parseInt(song.year) / 10) * 10;
            if (songDecade !== parseInt(decadeFilter)) return false;
          } else if (decadeFilter && !song.year) {
            return false;
          }

          // Video filter
          if (videoFilter && !song.videoUrl) return false;

          return true;
        });

        // Sort songs
        filtered.sort((a, b) => {
          switch (sortBy) {
            case "artist":
              return (a.artist || "").localeCompare(b.artist || "");
            case "difficulty":
              return (b.difficulty ?? -1) - (a.difficulty ?? -1);
            case "duration":
              return (a.songLength || 0) - (b.songLength || 0);
            case "year":
              return (b.year || "0").localeCompare(a.year || "0");
            case "name":
            default:
              return (a.name || "").localeCompare(b.name || "");
          }
        });

        // Re-add matching songs
        for (const song of filtered) {
          const item = createSongElement(song);
          songList.appendChild(item);
        }

        updateSongCount(filtered.length);
      }

      // Legacy function name for compatibility
      function filterSongs(query) {
        document.getElementById("searchInput").value = query;
        filterAndSortSongs();
      }

      // Update filter dropdowns with available options
      function updateFilterOptions() {
        const decades = new Set();

        for (const song of allSongs) {
          if (song.year) {
            const decade = Math.floor(parseInt(song.year) / 10) * 10;
            if (!isNaN(decade)) decades.add(decade);
          }
        }

        // Update decade filter
        const decadeSelect = document.getElementById("decadeFilter");
        const currentDecade = decadeSelect.value;
        decadeSelect.innerHTML = '<option value="">All Decades</option>';
        [...decades]
          .sort()
          .reverse()
          .forEach((decade) => {
            const opt = document.createElement("option");
            opt.value = decade;
            opt.textContent = `${decade}s`;
            decadeSelect.appendChild(opt);
          });
        decadeSelect.value = currentDecade;
      }

      // Set up filter/sort event listeners
      document
        .getElementById("decadeFilter")
        .addEventListener("change", (e) => {
          if (e.target.value) {
            trackEvent("filter_decade", { decade: e.target.value });
          }
          filterAndSortSongs();
        });
      document.getElementById("videoFilter").addEventListener("change", (e) => {
        if (e.target.checked) {
          trackEvent("filter_video_only");
        }
        filterAndSortSongs();
      });
      document.getElementById("sortSelect").addEventListener("change", (e) => {
        trackEvent("sort_songs", { sort_by: e.target.value });
        filterAndSortSongs();
      });

      // Clear all filters button
      document
        .getElementById("clearFilters")
        .addEventListener("click", clearAllFilters);

      // Function to check if any filters are active and show/hide clear button
      function updateClearFiltersVisibility() {
        const searchTerm = document.getElementById("searchInput").value.trim();
        const decadeFilter = document.getElementById("decadeFilter").value;
        const videoFilter = document.getElementById("videoFilter").checked;

        const hasActiveFilters = searchTerm || decadeFilter || videoFilter;
        const clearBtn = document.getElementById("clearFilters");

        if (hasActiveFilters) {
          clearBtn.classList.add("visible");
        } else {
          clearBtn.classList.remove("visible");
        }
      }

      // Function to clear all filters
      function clearAllFilters() {
        document.getElementById("searchInput").value = "";
        document.getElementById("decadeFilter").value = "";
        document.getElementById("videoFilter").checked = false;
        document.getElementById("clearSearch").classList.remove("visible");
        filterAndSortSongs();
      }

      // Pending song switch (for modal confirmation)
      let pendingSongSwitch = null;

      function showSwitchSongModal(song, element) {
        pendingSongSwitch = { song, element };

        // Pause the game if it's playing
        if (gameState.isPlaying && !gameState.isPaused) {
          pauseGame();
        }

        // Populate modal with new song info
        document.getElementById("modalAlbumArt").src = song.albumArtUrl;
        document.getElementById("modalSongTitle").innerHTML =
          unityRichTextToHtml(song.displayName);
        document.getElementById("modalSongArtist").innerHTML =
          unityRichTextToHtml(song.displayArtist);

        // Show modal
        document.getElementById("switchSongModal").classList.add("show");
      }

      function hideSwitchSongModal() {
        document.getElementById("switchSongModal").classList.remove("show");
        pendingSongSwitch = null;
      }

      function confirmSongSwitch() {
        if (!pendingSongSwitch) return;

        const { song, element } = pendingSongSwitch;
        hideSwitchSongModal();

        // If there's a score to save, prompt first
        if (gameState.score > 0) {
          showSaveScorePrompt("switch", { song, element });
        } else {
          // Stop current game and switch
          stopGame();
          doSelectSong(song, element);
        }
      }

      function selectSong(song, element) {
        // If currently playing or paused, show confirmation modal
        if (gameState.isPlaying || gameState.isPaused) {
          showSwitchSongModal(song, element);
          return;
        }

        doSelectSong(song, element);
      }

      function doSelectSong(song, element) {
        // Track song selection
        trackEvent("select_song", {
          song_title: song.name || song.title,
          song_artist: song.artist,
          has_video: !!song.videoUrl,
        });

        // Start audio preview for the selected song (fromSelection = true)
        stopAudioPreview(true);
        startAudioPreview(song, true);

        // Reset to song-specific scores when selecting a new song
        gameState.showAllScores = false;

        // Show and expand the now playing section when selecting a song
        const nowPlaying = document.getElementById("nowPlaying");
        nowPlaying.classList.remove("collapsed");
        nowPlaying.classList.remove("no-song");

        // Update selection UI
        document
          .querySelectorAll(".song-item")
          .forEach((el) => el.classList.remove("selected"));
        element.classList.add("selected");

        // Update now playing (use fancy display versions from ini)
        document.getElementById("albumArt").src = song.albumArtUrl;
        document.getElementById("currentSong").innerHTML = unityRichTextToHtml(
          song.displayName
        );
        document.getElementById("currentArtist").innerHTML =
          unityRichTextToHtml(song.displayArtist);

        // Update song metadata
        document.getElementById("songYear").textContent = song.year || "";
        document.getElementById("songDuration").textContent = song.songLength
          ? formatDuration(song.songLength)
          : "";

        // Update loading phrase (strip HTML for display)
        const loadingPhraseEl = document.getElementById("loadingPhrase");
        if (song.loadingPhrase) {
          loadingPhraseEl.textContent = song.loadingPhrase.replace(
            /<[^>]*>/g,
            ""
          );
        } else {
          loadingPhraseEl.textContent = "";
        }

        // Update mini player
        document.getElementById("miniAlbumArt").src = song.albumArtUrl;
        document.getElementById("miniSongTitle").innerHTML =
          unityRichTextToHtml(song.displayName);
        document.getElementById("miniArtist").innerHTML = unityRichTextToHtml(
          song.displayArtist
        );

        // Show/hide video indicator
        const videoIndicator = document.getElementById("videoIndicator");
        if (song.videoUrl) {
          videoIndicator.classList.add("active");
        } else {
          videoIndicator.classList.remove("active");
        }

        // Clear any previous video so it doesn't show over the background
        backgroundVideo.src = "";

        // Show background image if available (even before playing)
        // Mark as from selection so hover previews don't override immediately
        showBackgroundPreview(song, true);

        // Update instrument buttons with difficulty badges
        const instBtns = document.querySelectorAll(".instrument-btn");
        let firstAvailableInst = null;
        instBtns.forEach((btn) => {
          const inst = btn.dataset.instrument;
          const isAvailable =
            song.availableInstruments && song.availableInstruments[inst];
          btn.disabled = !isAvailable;
          btn.classList.remove("selected");

          // Update difficulty badge for this instrument
          const diffMap = {
            guitar: song.diffGuitar,
            bass: song.diffBass,
            drums: song.diffDrums,
            keys: song.diffKeys,
          };
          const diff = diffMap[inst];
          let badge = btn.querySelector(".diff-badge");
          if (isAvailable && diff !== undefined && diff >= 0) {
            if (!badge) {
              badge = document.createElement("span");
              badge.className = "diff-badge";
              btn.appendChild(badge);
            }
            // Create colored dots like the song list
            const maxDots = 6;
            const level = Math.min(Math.max(0, diff), maxDots);
            let dotsHtml = "";
            for (let i = 0; i < maxDots; i++) {
              if (i < level) {
                dotsHtml += `<span class="dot filled filled-${level}"></span>`;
              } else {
                dotsHtml += `<span class="dot"></span>`;
              }
            }
            badge.innerHTML = dotsHtml;
            badge.title = `Difficulty: ${level}/6`;
          } else if (badge) {
            badge.remove();
          }

          if (isAvailable && !firstAvailableInst) {
            firstAvailableInst = inst;
          }
        });

        // Select first available instrument if current is not available
        const currentInstAvailable =
          song.availableInstruments &&
          song.availableInstruments[gameState.instrument];
        if (!currentInstAvailable && firstAvailableInst) {
          gameState.instrument = firstAvailableInst;
          document
            .querySelector(
              `.instrument-btn[data-instrument="${firstAvailableInst}"]`
            )
            ?.classList.add("selected");
        } else if (currentInstAvailable) {
          document
            .querySelector(
              `.instrument-btn[data-instrument="${gameState.instrument}"]`
            )
            ?.classList.add("selected");
        }

        // Update available tracks for selected instrument
        updateDifficultyButtons(song);

        gameState.currentSong = song;
        document.getElementById("playBtn").disabled = false;
        document.getElementById("playBtn").textContent = "PLAY";
        document.getElementById("miniPlayBtn").disabled = false;
        document.getElementById("miniPlayBtn").textContent = "‚ñ∂";
        document.getElementById("restartBtn").disabled = false;

        // Update high scores to show song-specific scores
        updateHighScoresDisplay();
      }

      function updateDifficultyButtons(song) {
        const availableTracks = song.chartData.getAvailableTracks(
          gameState.instrument
        );
        const diffBtns = document.querySelectorAll(".diff-btn");

        // Clear all selections first
        diffBtns.forEach((btn) => {
          const diff = btn.dataset.diff;
          btn.disabled = !availableTracks.includes(diff);
          btn.classList.remove("selected");
        });

        // Select current difficulty if available, otherwise first available
        if (availableTracks.includes(gameState.difficulty)) {
          document
            .querySelector(`.diff-btn[data-diff="${gameState.difficulty}"]`)
            ?.classList.add("selected");
        } else if (availableTracks.length > 0) {
          const firstAvailable = availableTracks[0];
          document
            .querySelector(`.diff-btn[data-diff="${firstAvailable}"]`)
            ?.classList.add("selected");
          gameState.difficulty = firstAvailable;
        }
      }

      // ============================================
      // GAME RENDERING
      // ============================================

      function resizeCanvas() {
        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Calculate scale to fit the fixed-size app within the viewport
        const scaleX = viewportWidth / GAME_WIDTH;
        const scaleY = viewportHeight / GAME_HEIGHT;
        const scale = Math.min(scaleX, scaleY);

        // Apply transform to scale the entire app
        const appScaler = document.getElementById("appScaler");
        appScaler.style.transform = `translate(-50%, -50%) scale(${scale})`;

        // Set canvas to match the game area dimensions (within the fixed app)
        const gameArea = document.getElementById("gameArea");
        const rect = gameArea.getBoundingClientRect();
        // Since gameArea is inside the scaled app, get its unscaled dimensions
        canvas.width = gameArea.offsetWidth;
        canvas.height = gameArea.offsetHeight;
      }

      function drawGame() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawHighway();
        drawHitLine();
        drawNotes();
        drawHitEffects();
        updateLyrics();
        updateProgressBar();

        // Draw pause overlay if paused
        if (gameState.isPaused) {
          drawPauseOverlay();
        }

        if (gameState.isPlaying && !gameState.isPaused) {
          requestAnimationFrame(drawGame);
        }
      }

      function drawPauseOverlay() {
        // Semi-transparent overlay
        ctx.fillStyle = "rgba(10, 10, 15, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Pause icon
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2 - 30;
        const barWidth = 20;
        const barHeight = 60;
        const gap = 15;

        ctx.fillStyle = "rgba(168, 85, 247, 0.9)";
        ctx.shadowColor = "rgba(168, 85, 247, 0.8)";
        ctx.shadowBlur = 20;

        // Left bar
        ctx.fillRect(
          centerX - gap - barWidth,
          centerY - barHeight / 2,
          barWidth,
          barHeight
        );
        // Right bar
        ctx.fillRect(
          centerX + gap,
          centerY - barHeight / 2,
          barWidth,
          barHeight
        );

        ctx.shadowBlur = 0;

        // Paused text
        ctx.font = "bold 24px 'Orbitron', sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("PAUSED", centerX, centerY + 60);

        // Instructions
        ctx.font = "16px 'Rajdhani', sans-serif";
        ctx.fillStyle = "#888";
        ctx.fillText(
          "Press SPACE to resume ‚Ä¢ ESC to stop",
          centerX,
          centerY + 95
        );
      }

      function updateProgressBar() {
        const progressBar = document.getElementById("songProgressBar");
        const progressFill = document.getElementById("songProgressFill");

        if (!gameState.isPlaying || !gameState.audioElement) {
          progressBar.classList.remove("active");
          return;
        }

        progressBar.classList.add("active");
        const currentTime = gameState.audioElement.currentTime;

        // Use effective game duration (from skipToTime to endAfterTime)
        // so progress bar reaches 100% when game ends
        const effectiveStart = gameState.skipToTime || 0;
        const effectiveEnd =
          gameState.endAfterTime || gameState.audioElement.duration;
        const effectiveDuration = effectiveEnd - effectiveStart;

        if (effectiveDuration > 0) {
          const progress = Math.min(
            100,
            Math.max(
              0,
              ((currentTime - effectiveStart) / effectiveDuration) * 100
            )
          );
          progressFill.style.width = `${progress}%`;
        }
      }

      function updateLyrics() {
        if (!gameState.isPlaying || !gameState.currentSong) return;

        const chartData = gameState.currentSong.chartData;
        const lyricsSection = document.getElementById("lyricsSection");
        if (!chartData.hasLyrics || !chartData.hasLyrics()) {
          lyricsSection.classList.add("hidden");
          return;
        }

        const lyricsDisplay = document.getElementById("lyricsDisplay");
        lyricsSection.classList.remove("hidden");

        const currentTime = getCurrentAudioTime();

        // Find current phrase index
        let currentPhraseIndex = -1;
        for (let i = 0; i < chartData.lyrics.length; i++) {
          const phrase = chartData.lyrics[i];
          if (
            currentTime >= phrase.startTime - 500 &&
            currentTime <= phrase.endTime + 200
          ) {
            currentPhraseIndex = i;
            break;
          }
        }

        // If no active phrase, find the next upcoming one
        if (currentPhraseIndex === -1) {
          for (let i = 0; i < chartData.lyrics.length; i++) {
            if (chartData.lyrics[i].startTime > currentTime) {
              // Show the previous phrase if we're past it, otherwise nothing active yet
              if (i > 0 && currentTime > chartData.lyrics[i - 1].endTime) {
                currentPhraseIndex = i - 1;
              }
              break;
            }
          }
        }

        // Build all lyrics HTML once (when lyrics change or first load)
        if (
          !gameState.lyricsBuilt ||
          gameState.currentLyricGroupKey !== "all"
        ) {
          gameState.currentLyricGroupKey = "all";
          gameState.lyricsBuilt = true;

          // Build HTML for ALL phrases with spacers for centering
          let html = '<div class="lyrics-spacer"></div>';
          for (let i = 0; i < chartData.lyrics.length; i++) {
            const phrase = chartData.lyrics[i];
            const phraseText = phrase.words
              .map(
                (w) =>
                  unityRichTextToHtml(w.text) + (w.continuesWord ? "" : " ")
              )
              .join("")
              .trim();
            html += `<div class="lyric-phrase" data-phrase-idx="${i}">${phraseText}</div>`;
          }
          html += '<div class="lyrics-spacer"></div>';
          lyricsDisplay.innerHTML = html;
        }

        // Update highlighting and scroll position
        const phraseEls = lyricsDisplay.querySelectorAll(".lyric-phrase");
        phraseEls.forEach((el, i) => {
          const phrase = chartData.lyrics[i];
          const distance = Math.abs(i - currentPhraseIndex);

          // Remove all state classes
          el.classList.remove("active", "past", "near-1", "near-2");

          if (i === currentPhraseIndex) {
            el.classList.add("active");
            // Update word-by-word highlighting
            let html = "";
            for (const word of phrase.words) {
              const isSung = currentTime >= word.time;
              const text =
                unityRichTextToHtml(word.text) +
                (word.continuesWord ? "" : " ");
              if (isSung) {
                html += `<span class="sung">${text}</span>`;
              } else {
                html += text;
              }
            }
            el.innerHTML = html;

            // Scroll to center the active lyric
            const containerHeight = lyricsDisplay.clientHeight;
            const scrollTarget =
              el.offsetTop - containerHeight / 2 + el.offsetHeight / 2;
            lyricsDisplay.scrollTop = scrollTarget;
          } else if (i < currentPhraseIndex) {
            el.classList.add("past");
            if (distance === 1) el.classList.add("near-1");
          } else {
            // Future lyrics - add proximity classes
            if (distance === 1) el.classList.add("near-1");
            else if (distance === 2) el.classList.add("near-2");
          }
        });
      }

      function drawHighway() {
        const laneWidth = CONFIG.laneWidth;
        const numLanes = activeLaneCount;
        const totalWidth = laneWidth * numLanes;
        const startX = (canvas.width - totalWidth) / 2;
        const laneColors = getLaneColors();
        const laneKeys = getLaneKeys();

        // Highway background with perspective
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, "rgba(20, 20, 30, 0.9)");
        gradient.addColorStop(1, "rgba(10, 10, 15, 0.95)");

        ctx.fillStyle = gradient;
        ctx.fillRect(startX - 10, 0, totalWidth + 20, canvas.height);

        // Lane dividers
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= numLanes; i++) {
          const x = startX + i * laneWidth;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }

        // Fret buttons at bottom
        const fretY = canvas.height - CONFIG.hitLineY;
        for (let i = 0; i < numLanes; i++) {
          const x = startX + i * laneWidth + laneWidth / 2;
          const isPressed = pressedKeys.has(laneKeys[i]);

          // Check for lane flash (from hit/miss)
          const flash = laneFlashes[i];
          const flashAge = flash ? Date.now() - flash.time : 999999;
          const hasFlash = flashAge < 200; // Flash lasts 200ms

          // Lane flash effect (big bright flash on hit)
          if (hasFlash) {
            const flashAlpha = 1 - flashAge / 200;
            const flashGlow = ctx.createRadialGradient(
              x,
              fretY,
              0,
              x,
              fretY,
              laneWidth * 1.5
            );
            flashGlow.addColorStop(0, `rgba(${flash.color}, ${flashAlpha})`);
            flashGlow.addColorStop(
              0.5,
              `rgba(${flash.color}, ${flashAlpha * 0.5})`
            );
            flashGlow.addColorStop(1, "transparent");
            ctx.fillStyle = flashGlow;
            ctx.fillRect(
              startX + i * laneWidth - 20,
              fretY - 80,
              laneWidth + 40,
              160
            );
          }

          // Glow effect when pressed
          if (isPressed) {
            const glow = ctx.createRadialGradient(
              x,
              fretY,
              0,
              x,
              fretY,
              laneWidth
            );
            glow.addColorStop(0, laneColors[i] + "60");
            glow.addColorStop(1, "transparent");
            ctx.fillStyle = glow;
            ctx.fillRect(startX + i * laneWidth, fretY - 50, laneWidth, 100);
          }

          // Fret circle - make it flash white/bright on hit
          ctx.beginPath();
          ctx.arc(x, fretY, isPressed ? 28 : 24, 0, Math.PI * 2);

          if (hasFlash) {
            // Bright flash color
            const flashAlpha = 1 - flashAge / 200;
            ctx.fillStyle = `rgba(${flash.color}, ${0.8 + flashAlpha * 0.2})`;
            ctx.shadowColor = `rgba(${flash.color}, 1)`;
            ctx.shadowBlur = 30;
          } else if (isPressed) {
            ctx.fillStyle = laneColors[i];
            ctx.shadowBlur = 0;
          } else {
            ctx.fillStyle = "rgba(40, 40, 50, 0.9)";
            ctx.shadowBlur = 0;
          }
          ctx.fill();
          ctx.shadowBlur = 0;

          ctx.strokeStyle = hasFlash ? "#fff" : laneColors[i];
          ctx.lineWidth = hasFlash ? 4 : 3;
          ctx.stroke();

          // Key label - show gamepad labels if a gamepad device is selected
          const useGamepadLabels = selectedInputDevice !== "keyboard";
          ctx.fillStyle = isPressed || hasFlash ? "#000" : "#888";
          ctx.font = useGamepadLabels
            ? "bold 14px 'Orbitron', sans-serif"
            : "bold 16px 'Orbitron', sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const gamepadLabels = getGamepadLabels();
          const label = useGamepadLabels
            ? gamepadLabels[i]
            : laneKeys[i].toUpperCase();
          ctx.fillText(label, x, fretY);
        }
      }

      function drawHitLine() {
        const laneWidth = CONFIG.laneWidth;
        const totalWidth = laneWidth * activeLaneCount;
        const startX = (canvas.width - totalWidth) / 2;
        const y = canvas.height - CONFIG.hitLineY;

        // Hit line glow
        const gradient = ctx.createLinearGradient(startX, y - 5, startX, y + 5);
        gradient.addColorStop(0, "transparent");
        gradient.addColorStop(0.5, "rgba(168, 85, 247, 0.6)");
        gradient.addColorStop(1, "transparent");

        ctx.fillStyle = gradient;
        ctx.fillRect(startX, y - 5, totalWidth, 10);

        // Solid line
        ctx.strokeStyle = "rgba(168, 85, 247, 0.8)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(startX + totalWidth, y);
        ctx.stroke();
      }

      function drawNotes() {
        const laneWidth = CONFIG.laneWidth;
        const totalWidth = laneWidth * activeLaneCount;
        const startX = (canvas.width - totalWidth) / 2;
        const hitY = canvas.height - CONFIG.hitLineY;
        const laneColors = getLaneColors();
        const laneKeys = getLaneKeys();

        const currentTime = getCurrentAudioTime();

        for (const note of gameState.activeNotes) {
          if (note.missed) continue;

          // Check if this is a sustained note that was hit and is being held
          const isSustain = note.durationMs > 50; // More than 50ms = sustained note
          const isBeingHeld =
            note.hit && isSustain && pressedKeys.has(laneKeys[note.lane]);
          const sustainEndTime = note.time + note.durationMs;

          // For hit notes: skip if not a sustain, or if sustain is complete
          if (note.hit) {
            if (!isSustain) continue; // Short notes disappear on hit
            if (currentTime > sustainEndTime) continue; // Sustain complete
            // Keep showing sustain until it's done (visual feedback for player)
          }

          const timeUntilHit = note.time - currentTime;
          // y is where the NOTE HEAD (start) should be - this is what the player hits
          const noteHeadY = hitY - (timeUntilHit / 1000) * CONFIG.noteSpeed;

          // Note height based on sustain duration
          const minHeight = CONFIG.noteHeight;
          const sustainHeight = (note.durationMs / 1000) * CONFIG.noteSpeed;
          let noteHeight = Math.max(minHeight, sustainHeight);

          // For sustained notes, the tail extends UPWARD (earlier in time)
          let noteTop = noteHeadY - (noteHeight - minHeight);

          // If being held, shrink the sustain from the bottom (consume it as time passes)
          if (note.hit && isSustain) {
            // The remaining sustain shrinks as time passes
            const remainingTime = sustainEndTime - currentTime;
            const remainingHeight = Math.max(
              0,
              (remainingTime / 1000) * CONFIG.noteSpeed
            );
            noteHeight = Math.max(minHeight / 2, remainingHeight);
            noteTop = hitY - remainingHeight;
          }

          const noteBottom = note.hit ? hitY : noteHeadY + minHeight;

          // Only draw if visible
          if (noteBottom < 0 || noteTop > canvas.height) continue;

          const x = startX + note.lane * laneWidth;
          const color = laneColors[note.lane] || laneColors[0];

          // Dim the sustain if released early (not holding)
          const isHoldingOrUnhit = !note.hit || isBeingHeld;
          const opacity = isHoldingOrUnhit ? 1 : 0.4;

          // Note body (sustain tail extends upward from the head)
          ctx.globalAlpha = opacity;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.roundRect(x + 8, noteTop, laneWidth - 16, noteHeight, 6);
          ctx.fill();

          // Note glow (stronger when being held)
          ctx.shadowColor = color;
          ctx.shadowBlur = note.hit ? 25 : 15;
          ctx.fill();
          ctx.shadowBlur = 0;

          // Note head (brighter circle at the hit point) - only for unhit notes
          if (!note.hit) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(
              x + laneWidth / 2,
              noteHeadY,
              (laneWidth - 16) / 2,
              0,
              Math.PI * 2
            );
            ctx.fill();

            // Head highlight
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.beginPath();
            ctx.arc(
              x + laneWidth / 2,
              noteHeadY - 4,
              (laneWidth - 24) / 2,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }

          // Highlight on sustain
          const highlight = ctx.createLinearGradient(
            x + 8,
            noteTop,
            x + laneWidth - 8,
            noteTop
          );
          highlight.addColorStop(0, "rgba(255, 255, 255, 0.3)");
          highlight.addColorStop(0.5, "transparent");
          highlight.addColorStop(1, "rgba(0, 0, 0, 0.2)");
          ctx.fillStyle = highlight;
          ctx.beginPath();
          ctx.roundRect(x + 8, noteTop, laneWidth - 16, noteHeight, 6);
          ctx.fill();

          // Reset alpha for next note
          ctx.globalAlpha = 1;
        }
      }

      let hitEffects = [];
      let laneFlashes = {}; // Track lane flash effects

      function drawHitEffects() {
        const laneWidth = CONFIG.laneWidth;
        const totalWidth = laneWidth * activeLaneCount;
        const startX = (canvas.width - totalWidth) / 2;
        const hitY = canvas.height - CONFIG.hitLineY;

        hitEffects = hitEffects.filter((effect) => {
          const age = Date.now() - effect.time;

          // Sustain ticks have shorter duration
          const maxAge = effect.type === "sustainTick" ? 300 : 600;
          if (age > maxAge) return false;

          const alpha = 1 - age / maxAge;
          const x = startX + effect.lane * laneWidth + laneWidth / 2;

          // Sustain tick effects - subtle, no rings
          if (effect.type === "sustainTick") {
            // Small floating number with dark outline for visibility on all colors
            const textY = hitY - 30 - age / 8;
            ctx.save();
            ctx.font = "bold 14px 'Orbitron', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Dark outline for visibility on any background
            ctx.strokeStyle = `rgba(0, 0, 0, ${alpha * 0.8})`;
            ctx.lineWidth = 3;
            ctx.strokeText(effect.text, x, textY);

            // White fill for consistent visibility
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillText(effect.text, x, textY);
            ctx.restore();
            return true;
          }

          // Multiple expanding rings (not for sustain ticks)
          const ringCount = effect.type === "sustainComplete" ? 4 : 3;
          for (let ring = 0; ring < ringCount; ring++) {
            const ringAge = age - ring * 50;
            if (ringAge > 0 && ringAge < 400) {
              const ringAlpha = (1 - ringAge / 400) * alpha;
              const ringSize = 25 + ringAge / 5;
              ctx.beginPath();
              ctx.arc(x, hitY, ringSize, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(${effect.color}, ${ringAlpha})`;
              ctx.lineWidth = 4 - ring;
              ctx.stroke();
            }
          }

          // Particle burst for hits and sustain complete
          if (effect.type === "hit" || effect.type === "sustainComplete") {
            const numParticles = effect.type === "sustainComplete" ? 12 : 8;
            for (let p = 0; p < numParticles; p++) {
              const angle = (p / numParticles) * Math.PI * 2;
              const dist = 20 + age / 8;
              const px = x + Math.cos(angle) * dist;
              const py = hitY + Math.sin(angle) * dist;
              const particleSize = Math.max(1, 4 - age / 150);

              ctx.beginPath();
              ctx.arc(px, py, particleSize, 0, Math.PI * 2);
              ctx.fillStyle = `rgba(${effect.color}, ${alpha})`;
              ctx.fill();
            }
          }

          // Big floating text with glow
          const textY = hitY - 60 - age / 12;
          const scale = 1 + (age < 100 ? (100 - age) / 200 : 0); // Pop effect
          const fontSize = effect.type === "sustainComplete" ? 28 : 24;

          ctx.save();
          ctx.translate(x, textY);
          ctx.scale(scale, scale);

          // Text shadow/glow
          ctx.font = `bold ${fontSize}px 'Orbitron', sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowColor = `rgba(${effect.color}, 1)`;
          ctx.shadowBlur = effect.type === "sustainComplete" ? 20 : 15;
          ctx.fillStyle = `rgba(${effect.color}, ${alpha})`;
          ctx.fillText(effect.text, 0, 0);

          // White inner text
          ctx.shadowBlur = 0;
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`;
          ctx.fillText(effect.text, 0, 0);

          ctx.restore();

          return true;
        });
      }

      // ============================================
      // GAME LOGIC
      // ============================================

      function getCurrentAudioTime() {
        if (!gameState.audioElement) return 0;
        return gameState.audioElement.currentTime * 1000;
      }

      function startGame() {
        if (!gameState.currentSong) return;

        // Track game start
        trackEvent("game_start", {
          song_title: gameState.currentSong.name || gameState.currentSong.title,
          song_artist: gameState.currentSong.artist,
          instrument: gameState.instrument,
          difficulty: gameState.difficulty,
          lane_count: activeLaneCount,
        });

        // Stop any audio preview before starting the game
        stopAudioPreview(true);

        resetGame();

        // Update lane count from current selection
        gameState.laneCount = activeLaneCount;

        // Get notes for selected difficulty and instrument
        const originalNotes = gameState.currentSong.chartData.getNotes(
          gameState.difficulty,
          gameState.instrument
        );

        // Remap notes to current lane count (with deduplication)
        const notes = remapNotesToLanes(originalNotes);
        gameState.notes = notes;
        gameState.activeNotes = notes.map((n) => ({
          ...n,
          hit: false,
          missed: false,
        }));

        // Auto-skip to first note: find when the first note appears
        // and fast-forward to a few seconds before it
        const OVERLAY_DISPLAY_SECONDS = 3; // Fixed time to show overlay
        const NOTE_TRAVEL_SECONDS = 2; // How long notes take to travel down screen
        const TOTAL_BUFFER_SECONDS =
          OVERLAY_DISPLAY_SECONDS + NOTE_TRAVEL_SECONDS; // Total buffer needed
        const END_BUFFER_SECONDS = 5; // Seconds after last note to end song
        let skipToTime = 0;
        let startDelay = 0; // Delay before starting audio (for songs that start too fast)
        let endAfterTime = null;
        const overlayDuration = OVERLAY_DISPLAY_SECONDS * 1000; // Fixed overlay duration

        if (notes.length > 0) {
          const firstNoteTimeMs = notes[0].time;
          const firstNoteTimeSec = firstNoteTimeMs / 1000;

          // Calculate ideal skip time (can be negative if song starts too fast)
          const idealSkipTime = firstNoteTimeSec - TOTAL_BUFFER_SECONDS;

          if (idealSkipTime >= 0) {
            // Normal case: skip forward to the right spot
            skipToTime = idealSkipTime;
          } else {
            // Song starts too fast: delay audio start instead
            skipToTime = 0;
            startDelay = Math.abs(idealSkipTime) * 1000; // Convert to ms
          }

          // Find the last note time to end the song early
          const lastNoteTimeMs = notes[notes.length - 1].time;
          const lastNoteTimeSec = lastNoteTimeMs / 1000;
          endAfterTime = lastNoteTimeSec + END_BUFFER_SECONDS;
        }
        gameState.skipToTime = skipToTime;
        gameState.startDelay = startDelay;
        gameState.endAfterTime = endAfterTime;

        // Show loading phrase overlay with fixed duration
        showLoadingPhraseOverlay(overlayDuration);

        // Setup video if available
        if (gameState.currentSong.videoUrl) {
          backgroundVideo.src = gameState.currentSong.videoUrl;
          // Apply video start time offset (negative offset means video starts ahead)
          const videoOffset =
            (gameState.currentSong.videoStartTime || 0) / 1000;
          backgroundVideo.currentTime = Math.max(0, -videoOffset);
          backgroundVideo.load();
          gameState.videoElement = backgroundVideo;
          // Hide background image when video will play
          backgroundImage.classList.remove("active");
        } else {
          gameState.videoElement = null;
          backgroundVideo.src = "";
          // Keep background image if present (including album art fallback), otherwise hide container
          if (
            !gameState.currentSong.backgroundUrl &&
            !gameState.currentSong.albumArtUrl
          ) {
            videoContainer.classList.remove("active");
          }
        }

        // Setup audio
        gameState.audioElement = new Audio(gameState.currentSong.audioUrl);
        gameState.audioElement.addEventListener("ended", handleSongComplete);
        gameState.audioElement.addEventListener(
          "canplaythrough",
          () => {
            // Fast-forward to just before the first note
            if (gameState.skipToTime > 0) {
              gameState.audioElement.currentTime = gameState.skipToTime;
            }

            // Function to actually start playback
            const beginPlayback = () => {
              // Start audio
              gameState.audioElement.play();

              // Sync and start video if available
              if (gameState.videoElement) {
                gameState.videoElement.currentTime = gameState.skipToTime || 0;
                gameState.videoElement
                  .play()
                  .catch((e) => console.log("Video play failed:", e));
                videoContainer.classList.add("active");

                // Sync video with audio periodically
                startVideoSync();
              }

              gameState.isPlaying = true;
              gameState.isPaused = false;
              gameState.startTime = Date.now();

              // Reset and start volume control
              resetVolume();
              updateVolume();

              updatePlayButtonState();
              updateLeftPanelVisibility();

              requestAnimationFrame(gameLoop);
              drawGame();
            };

            // If song starts too fast, delay audio to ensure consistent overlay timing
            if (gameState.startDelay > 0) {
              setTimeout(beginPlayback, gameState.startDelay);
            } else {
              beginPlayback();
            }
          },
          { once: true }
        );

        gameState.audioElement.load();
      }

      // Keep video synced with audio
      let videoSyncInterval = null;
      function startVideoSync() {
        if (videoSyncInterval) clearInterval(videoSyncInterval);

        // Get video start time offset from song.ini (in milliseconds, convert to seconds)
        // Negative values mean video should start before audio
        // Positive values mean video should start after audio
        const videoOffset = (gameState.currentSong?.videoStartTime || 0) / 1000;

        videoSyncInterval = setInterval(() => {
          if (
            !gameState.isPlaying ||
            gameState.isPaused ||
            !gameState.videoElement ||
            !gameState.audioElement
          ) {
            clearInterval(videoSyncInterval);
            return;
          }

          const audioTime = gameState.audioElement.currentTime;
          // Calculate target video time based on audio time and offset
          // If offset is -1000ms (-1s), when audio is at 0s, video should be at 1s
          const targetVideoTime = audioTime - videoOffset;
          const videoTime = gameState.videoElement.currentTime;
          const drift = Math.abs(targetVideoTime - videoTime);

          // If drift is more than 0.1 seconds, resync
          if (drift > 0.1 && targetVideoTime >= 0) {
            gameState.videoElement.currentTime = targetVideoTime;
          }
        }, 500);
      }

      // Pulse effect on hit
      function pulseVideoGlow() {
        // Apply glow effects if we have a video or background image (including album art)
        if (
          !gameState.videoElement &&
          !gameState.currentSong?.backgroundUrl &&
          !gameState.currentSong?.albumArtUrl
        )
          return;

        videoGlow.classList.add("pulse");
        setTimeout(() => videoGlow.classList.remove("pulse"), 150);
      }

      // Update video glow color based on combo tier
      function updateVideoIntensity() {
        const combo = gameState.combo;

        // Remove all glow tier classes
        videoGlow.classList.remove(
          "glow-fire",
          "glow-blazing",
          "glow-unstoppable",
          "glow-legendary",
          "glow-godlike",
          "glow-perfection"
        );

        // Apply appropriate tier class based on combo
        if (combo >= 200) {
          videoGlow.classList.add("glow-perfection");
        } else if (combo >= 150) {
          videoGlow.classList.add("glow-godlike");
        } else if (combo >= 100) {
          videoGlow.classList.add("glow-legendary");
        } else if (combo >= 75) {
          videoGlow.classList.add("glow-unstoppable");
        } else if (combo >= 50) {
          videoGlow.classList.add("glow-blazing");
        } else if (combo >= 25) {
          videoGlow.classList.add("glow-fire");
        }
        // combo < 25 uses default purple (no tier class needed)
      }

      // Called when song finishes naturally (audio ended)
      function handleSongComplete() {
        gameState.songCompleted = true;

        // Track song completion with stats
        const totalNotes =
          gameState.perfectCount +
          gameState.goodCount +
          gameState.okCount +
          gameState.missedCount;
        const accuracy =
          totalNotes > 0
            ? Math.round(
                ((gameState.perfectCount + gameState.goodCount) / totalNotes) *
                  100
              )
            : 0;

        trackEvent("song_complete", {
          song_title:
            gameState.currentSong?.name || gameState.currentSong?.title,
          song_artist: gameState.currentSong?.artist,
          instrument: gameState.instrument,
          difficulty: gameState.difficulty,
          lane_count: gameState.laneCount,
          final_score: gameState.score,
          max_combo: gameState.maxCombo,
          perfect_count: gameState.perfectCount,
          good_count: gameState.goodCount,
          ok_count: gameState.okCount,
          missed_count: gameState.missedCount,
          accuracy_percent: accuracy,
        });

        stopGame();

        // Show name entry modal with final score
        showNameEntryModal();
      }

      // Generate a consistent song ID using the chart file checksum
      function generateSongId(song) {
        // Use the chart hash if available (most reliable)
        if (song?.chartHash) {
          return song.chartHash;
        }
        // Fallback to title+artist for edge cases
        const title = song?.title || song?.name || "Unknown";
        const artist = song?.artist || "Unknown";
        return (title + "-" + artist)
          .toLowerCase()
          .replace(/[^a-z0-9]/g, "-")
          .replace(/-+/g, "-")
          .replace(/^-|-$/g, "")
          .slice(0, 50);
      }

      // Compute a simple hash/checksum of a string (for chart file identification)
      async function computeChartHash(content) {
        // Use SubtleCrypto for a proper hash if available
        if (crypto.subtle) {
          const encoder = new TextEncoder();
          const data = encoder.encode(content);
          const hashBuffer = await crypto.subtle.digest("SHA-256", data);
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          // Return first 16 hex chars (64 bits) for a compact but unique ID
          return hashArray
            .slice(0, 8)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        }
        // Fallback: simple djb2 hash
        let hash = 5381;
        for (let i = 0; i < content.length; i++) {
          hash = ((hash << 5) + hash) ^ content.charCodeAt(i);
        }
        return Math.abs(hash).toString(16);
      }

      // Compute hash from ArrayBuffer (for MIDI files)
      async function computeChartHashFromBuffer(buffer) {
        if (crypto.subtle) {
          const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          return hashArray
            .slice(0, 8)
            .map((b) => b.toString(16).padStart(2, "0"))
            .join("");
        }
        // Fallback: djb2 hash on bytes
        const bytes = new Uint8Array(buffer);
        let hash = 5381;
        for (let i = 0; i < bytes.length; i++) {
          hash = ((hash << 5) + hash) ^ bytes[i];
        }
        return Math.abs(hash).toString(16);
      }

      // Show name entry modal
      function showNameEntryModal() {
        const modal = document.getElementById("nameEntryModal");
        const finalScoreDisplay = document.getElementById("finalScoreDisplay");
        const nameInput = document.getElementById("playerNameInput");

        // Display the final score
        finalScoreDisplay.textContent = gameState.score.toLocaleString();

        // Display the stats
        document.getElementById("modalPerfect").textContent =
          gameState.perfectCount;
        document.getElementById("modalGood").textContent = gameState.goodCount;
        document.getElementById("modalOk").textContent = gameState.okCount;
        document.getElementById("modalMissed").textContent =
          gameState.missedCount;
        document.getElementById("modalMaxCombo").textContent =
          gameState.maxCombo;

        // Clear previous input
        nameInput.value = "";

        // Show modal
        modal.classList.add("show");

        // Focus the input
        setTimeout(() => nameInput.focus(), 100);
      }

      // Hide name entry modal
      function hideNameEntryModal() {
        document.getElementById("nameEntryModal").classList.remove("show");
      }

      // Save score prompt - tracks pending action after prompt
      let pendingSavePromptAction = null; // { type: 'stop' | 'restart' | 'switch', data?: any }
      let promptPausedGame = false; // Track if the prompt paused the game (vs user already paused)

      // Show save score prompt before stopping/restarting/switching
      function showSaveScorePrompt(actionType, actionData = null) {
        // Only show if there's actually a score to save
        if (gameState.score === 0 || !gameState.currentSong) {
          executePendingAction(actionType, actionData);
          return;
        }

        pendingSavePromptAction = { type: actionType, data: actionData };

        // Pause the game if playing (track whether we paused it)
        if (gameState.isPlaying && !gameState.isPaused) {
          pauseGame();
          promptPausedGame = true;
        } else {
          promptPausedGame = false;
        }

        // Update the score display in the prompt
        document.getElementById("promptScoreDisplay").textContent =
          gameState.score.toLocaleString();

        // Show the prompt
        document.getElementById("saveScorePrompt").classList.add("show");
      }

      // Hide save score prompt
      function hideSaveScorePrompt() {
        document.getElementById("saveScorePrompt").classList.remove("show");
        pendingSavePromptAction = null;
      }

      // Execute the pending action (stop, restart, or switch)
      function executePendingAction(actionType, actionData) {
        switch (actionType) {
          case "stop":
            stopGame();
            break;
          case "restart":
            doRestartGame();
            break;
          case "switch":
            if (actionData) {
              stopGame();
              doSelectSong(actionData.song, actionData.element);
            }
            break;
        }
      }

      // Handle "Save Score" button in prompt
      async function handlePromptSave() {
        if (!pendingSavePromptAction) return;

        const action = pendingSavePromptAction;
        hideSaveScorePrompt();

        // Show the name entry modal
        showNameEntryModal();

        // Store the action to execute after score submission
        pendingSavePromptAction = action;
      }

      // Handle "Don't Save" button in prompt
      function handlePromptNoSave() {
        if (!pendingSavePromptAction) return;

        const { type, data } = pendingSavePromptAction;
        hideSaveScorePrompt();
        promptPausedGame = false;
        executePendingAction(type, data);
      }

      // Modified hide name entry to execute pending action if any
      function hideNameEntryModalAndContinue() {
        hideNameEntryModal();

        // If there was a pending action from save prompt, execute it
        if (pendingSavePromptAction) {
          const { type, data } = pendingSavePromptAction;
          pendingSavePromptAction = null;
          promptPausedGame = false; // Reset to prevent state inconsistency
          executePendingAction(type, data);
        }
      }

      // Submit score to the API
      async function submitScore(playerName) {
        if (!playerName || !gameState.currentSong) return;

        const song = gameState.currentSong;
        const songId = generateSongId(song);
        const songTitle = song.title || song.name || "Unknown Song";

        // Track score submission
        trackEvent("score_submit", {
          song_title: song.name || song.title,
          song_artist: song.artist,
          player_name: playerName,
          final_score: gameState.score,
          max_combo: gameState.maxCombo,
        });

        try {
          const response = await fetch("/api/key-frenzy/scores", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              name: playerName,
              score: gameState.score,
              song: songTitle,
              songId: songId,
              laneCount: gameState.laneCount,
              instrument: gameState.instrument,
              inputDevice: selectedInputDevice,
              stats: {
                perfect: gameState.perfectCount,
                good: gameState.goodCount,
                ok: gameState.okCount,
                missed: gameState.missedCount,
                maxCombo: gameState.maxCombo,
              },
              // Song metadata for first-time storage in Redis
              songMeta: {
                name: song.name || songTitle,
                artist: song.artist || "Unknown Artist",
                album: song.album || "",
                charter: song.charter || "",
                displayName: song.displayName || song.name || songTitle,
                displayArtist:
                  song.displayArtist || song.artist || "Unknown Artist",
              },
            }),
          });

          if (!response.ok) {
            console.error("Failed to submit score:", await response.text());
          }
        } catch (error) {
          console.error("Error submitting score:", error);
        }

        // Refresh the high scores display
        updateHighScoresDisplay();
      }

      // Fetch high scores from the API
      async function fetchHighScores(songId = null) {
        try {
          const url = songId
            ? `/api/key-frenzy/scores?song=${encodeURIComponent(songId)}`
            : "/api/key-frenzy/scores";

          const response = await fetch(url);
          if (!response.ok) {
            console.error("Failed to fetch scores:", response.status);
            return [];
          }

          const data = await response.json();
          return data.scores || [];
        } catch (error) {
          console.error("Error fetching high scores:", error);
          return [];
        }
      }

      // Escape HTML entities to prevent XSS
      function escapeHtml(text) {
        if (!text) return "";
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // Render high scores list HTML
      function renderHighScoresList(scores, showSongName) {
        if (scores.length === 0) {
          return `
            <div class="no-high-scores">
              <div class="empty-icon">üé∏</div>
              <p>No scores yet! Be the first to set a high score.</p>
            </div>
          `;
        }

        return scores
          .map((entry, index) => {
            const rankClass =
              index === 0
                ? "gold"
                : index === 1
                ? "silver"
                : index === 2
                ? "bronze"
                : "";
            const safeName = escapeHtml(entry.name);
            const safeDate = escapeHtml(entry.date || "");

            // Build song line with metadata when available
            let songLine = "";
            if (showSongName) {
              const meta = entry.songMeta;
              if (meta) {
                // Use plain name/artist (displayName/displayArtist contain Unity rich text markup)
                const songTitle = escapeHtml(meta.name || entry.song);
                const artistName = escapeHtml(meta.artist || "");
                songLine = `<div class="high-score-song">${songTitle}${
                  artistName
                    ? ` <span class="high-score-artist">by ${artistName}</span>`
                    : ""
                }</div>`;
              } else {
                const safeSong = escapeHtml(entry.song);
                songLine = safeSong
                  ? `<div class="high-score-song">${safeSong}</div>`
                  : "";
              }
            }

            // Build stats line - show input device, instrument, lane count, then stats if available
            let statsLine = "";
            // Input device icons (what controller they used)
            const INPUT_DEVICE_ICONS = {
              keyboard: { icon: "‚å®Ô∏è", name: "Keyboard" },
              drums: { icon: "ü•Å", name: "Drum Controller" },
              guitar: { icon: "üé∏", name: "Guitar Controller" },
              procontroller: { icon: "üéÆ", name: "Pro Controller" },
            };
            const deviceInfo =
              entry.inputDevice && INPUT_DEVICE_ICONS[entry.inputDevice];
            const deviceBadge = deviceInfo
              ? `<span class="hs-stat input-device" title="${deviceInfo.name}">${deviceInfo.icon}</span>`
              : "";
            const instInfo = entry.instrument && INSTRUMENTS[entry.instrument];
            const instBadge = instInfo
              ? `<span class="hs-stat instrument" title="${instInfo.name} track">${instInfo.icon}</span>`
              : "";
            const lanesBadge = entry.laneCount
              ? `<span class="hs-stat lanes">${entry.laneCount}L</span>`
              : "";
            if (entry.stats) {
              const s = entry.stats;
              statsLine = `
                <div class="high-score-stats">
                  ${deviceBadge}${instBadge}${lanesBadge}
                  <span class="hs-stat compact"><span class="perfect">${
                    s.perfect || 0
                  }</span>/<span class="good">${
                s.good || 0
              }</span>/<span class="ok">${
                s.ok || 0
              }</span>/<span class="missed">${
                s.missed || 0
              }</span>/<span class="combo">${s.maxCombo || 0}x</span></span>
                </div>
              `;
            } else if (deviceBadge || instBadge || lanesBadge) {
              statsLine = `<div class="high-score-stats">${deviceBadge}${instBadge}${lanesBadge}</div>`;
            }
            return `
            <div class="high-score-item ${rankClass}">
              <div class="high-score-rank">${index + 1}</div>
              <div class="high-score-info">
                <div class="high-score-name">${safeName}</div>
                ${songLine}
                ${statsLine}
                <div class="high-score-date">${safeDate}</div>
              </div>
              <div class="high-score-score">${entry.score.toLocaleString()}</div>
            </div>
          `;
          })
          .join("");
      }

      // Update high scores display based on current song selection
      async function updateHighScoresDisplay() {
        const subtitle = document.getElementById("highScoreSubtitle");
        const list = document.getElementById("highScoreList");

        let scores;
        let showSongName = false;

        // Determine if we should show song-specific or all scores
        const showSongScores =
          gameState.currentSong && !gameState.showAllScores;

        if (showSongScores) {
          // Show scores for the selected song
          const songTitle = escapeHtml(
            gameState.currentSong.title ||
              gameState.currentSong.name ||
              "Unknown Song"
          );
          const songId = generateSongId(gameState.currentSong);

          // Make subtitle clickable to view all scores
          subtitle.innerHTML = `
            <span class="back-arrow">‚Üê</span>
            <span class="song-name">${songTitle}</span>
            <span class="view-all-hint">View All</span>
          `;
          subtitle.classList.add("clickable");

          // Show loading state
          list.innerHTML =
            '<div class="no-high-scores"><p>Loading scores...</p></div>';

          scores = await fetchHighScores(songId);
        } else {
          // Show overall high scores
          subtitle.innerHTML = "All Songs";
          subtitle.classList.remove("clickable");

          // Show loading state
          list.innerHTML =
            '<div class="no-high-scores"><p>Loading scores...</p></div>';

          scores = await fetchHighScores();
          showSongName = true;
        }

        // Render the high score list
        list.innerHTML = renderHighScoresList(scores, showSongName);
      }

      // Toggle between song-specific and all scores
      function toggleHighScoresView() {
        if (gameState.currentSong && !gameState.showAllScores) {
          gameState.showAllScores = true;
          updateHighScoresDisplay();
        }
      }

      function updateLeftPanelVisibility() {
        const highScoresSection = document.getElementById("highScoresSection");
        const scoreSection = document.getElementById("scoreSection");
        const statsSection = document.getElementById("statsSection");
        const lyricsSection = document.getElementById("lyricsSection");

        if (gameState.isPlaying || gameState.isPaused) {
          // Song is playing or paused - show score/stats, hide high scores
          highScoresSection.classList.add("hidden");
          scoreSection.classList.remove("hidden");
          statsSection.classList.remove("hidden");
          // Lyrics shown separately based on whether song has lyrics
        } else if (gameState.songCompleted) {
          // Song just completed - show high scores AND score/stats, hide lyrics
          highScoresSection.classList.remove("hidden");
          scoreSection.classList.remove("hidden");
          statsSection.classList.remove("hidden");
          lyricsSection.classList.add("hidden");
          updateHighScoresDisplay(); // Update to show song-specific scores
        } else {
          // No song playing (idle state) - show only high scores
          highScoresSection.classList.remove("hidden");
          scoreSection.classList.add("hidden");
          statsSection.classList.add("hidden");
          lyricsSection.classList.add("hidden");
          updateHighScoresDisplay(); // Update based on song selection
        }
      }

      function stopGame() {
        // Track manual stop (not song completion)
        if (!gameState.songCompleted && gameState.score > 0) {
          trackEvent("game_stop", {
            song_title:
              gameState.currentSong?.name || gameState.currentSong?.title,
            final_score: gameState.score,
            max_combo: gameState.maxCombo,
          });
        }

        gameState.isPlaying = false;
        gameState.isPaused = false;

        // Hide loading phrase overlay
        hideLoadingPhraseOverlay();

        // Stop volume animation
        if (volumeAnimationId) {
          cancelAnimationFrame(volumeAnimationId);
          volumeAnimationId = null;
        }

        if (gameState.audioElement) {
          gameState.audioElement.pause();
          gameState.audioElement = null;
        }

        // Stop video
        if (gameState.videoElement) {
          gameState.videoElement.pause();
          gameState.videoElement = null;
        }
        // Clear video source so it doesn't show last frame over the background
        backgroundVideo.src = "";

        // Restore background image if available (use album art as fallback), otherwise hide container
        const bgUrl =
          gameState.currentSong?.backgroundUrl ||
          gameState.currentSong?.albumArtUrl;
        if (bgUrl) {
          backgroundImage.src = bgUrl;
          backgroundImage.classList.add("active");
          videoContainer.classList.add("active");
        } else {
          backgroundImage.classList.remove("active");
          videoContainer.classList.remove("active");
        }

        // Clear video sync interval
        if (videoSyncInterval) {
          clearInterval(videoSyncInterval);
          videoSyncInterval = null;
        }

        updatePlayButtonState();
        updateLeftPanelVisibility();

        // Hide lyrics display (handled by updateLeftPanelVisibility, but also clear content)
        document.getElementById("lyricsDisplay").innerHTML = "";
        gameState.lyricsBuilt = false;

        // Hide and reset progress bar
        document.getElementById("songProgressBar").classList.remove("active");
        document.getElementById("songProgressFill").style.width = "0%";

        drawStaticScreen();
      }

      function pauseGame() {
        if (!gameState.isPlaying || gameState.isPaused) return;

        // Track game pause
        trackEvent("game_pause", {
          song_title:
            gameState.currentSong?.name || gameState.currentSong?.title,
          current_score: gameState.score,
          current_combo: gameState.combo,
        });

        gameState.isPaused = true;
        gameState.pausedTime = gameState.audioElement?.currentTime || 0;

        // Pause audio
        if (gameState.audioElement) {
          gameState.audioElement.pause();
        }

        // Pause video
        if (gameState.videoElement) {
          gameState.videoElement.pause();
        }

        // Clear video sync interval while paused
        if (videoSyncInterval) {
          clearInterval(videoSyncInterval);
          videoSyncInterval = null;
        }

        // Stop volume animation
        if (volumeAnimationId) {
          cancelAnimationFrame(volumeAnimationId);
          volumeAnimationId = null;
        }

        updatePlayButtonState();
        updateLeftPanelVisibility();

        // Draw once more to show pause overlay
        drawGame();
      }

      function resumeGame() {
        if (!gameState.isPlaying || !gameState.isPaused) return;

        // Track game resume
        trackEvent("game_resume", {
          song_title:
            gameState.currentSong?.name || gameState.currentSong?.title,
        });

        gameState.isPaused = false;

        // Resume audio
        if (gameState.audioElement) {
          gameState.audioElement.play();
        }

        // Resume video
        if (gameState.videoElement) {
          gameState.videoElement
            .play()
            .catch((e) => console.log("Video play failed:", e));
          startVideoSync();
        }

        // Resume volume animation
        updateVolume();

        // Resume game loop and rendering
        requestAnimationFrame(gameLoop);
        requestAnimationFrame(drawGame);

        updatePlayButtonState();
        updateLeftPanelVisibility();
      }

      function restartGame() {
        if (!gameState.currentSong) return;

        // If there's a score to save and game is in progress, prompt first
        if (
          (gameState.isPlaying || gameState.isPaused) &&
          gameState.score > 0
        ) {
          showSaveScorePrompt("restart");
          return;
        }

        doRestartGame();
      }

      function doRestartGame() {
        if (!gameState.currentSong) return;

        // Track game restart
        trackEvent("game_restart", {
          song_title:
            gameState.currentSong?.name || gameState.currentSong?.title,
          previous_score: gameState.score,
        });

        // Stop current playback
        if (gameState.isPlaying || gameState.isPaused) {
          gameState.isPlaying = false;
          gameState.isPaused = false;

          if (gameState.audioElement) {
            gameState.audioElement.pause();
            gameState.audioElement = null;
          }

          if (gameState.videoElement) {
            gameState.videoElement.pause();
          }

          if (videoSyncInterval) {
            clearInterval(videoSyncInterval);
            videoSyncInterval = null;
          }
        }

        // Start fresh
        startGame();
      }

      function togglePlayPause() {
        if (!gameState.currentSong) return;

        if (!gameState.isPlaying) {
          startGame();
        } else if (gameState.isPaused) {
          resumeGame();
        } else {
          pauseGame();
        }
      }

      function updatePlayButtonState() {
        const playBtn = document.getElementById("playBtn");
        const miniPlayBtn = document.getElementById("miniPlayBtn");
        const stopBtn = document.getElementById("stopBtn");
        const restartBtn = document.getElementById("restartBtn");

        playBtn.classList.remove("playing", "paused");
        miniPlayBtn.classList.remove("playing", "paused");

        if (!gameState.isPlaying) {
          playBtn.textContent = "PLAY";
          miniPlayBtn.textContent = "‚ñ∂";
          stopBtn.disabled = true;
          restartBtn.disabled = !gameState.currentSong;
        } else if (gameState.isPaused) {
          playBtn.textContent = "RESUME";
          playBtn.classList.add("paused");
          miniPlayBtn.textContent = "‚ñ∂";
          miniPlayBtn.classList.add("paused");
          stopBtn.disabled = false;
          restartBtn.disabled = false;
        } else {
          playBtn.textContent = "PAUSE";
          playBtn.classList.add("playing");
          miniPlayBtn.textContent = "‚è∏";
          miniPlayBtn.classList.add("playing");
          stopBtn.disabled = false;
          restartBtn.disabled = false;
        }
      }

      // Loading phrase overlay functions
      let loadingPhraseTimeout = null;

      function showLoadingPhraseOverlay(duration = 4000) {
        const song = gameState.currentSong;
        if (!song) return;

        const overlay = document.getElementById("loadingPhraseOverlay");
        const songEl = document.getElementById("loadingPhraseSong");
        const artistEl = document.getElementById("loadingPhraseArtist");
        const phraseEl = document.getElementById("loadingPhraseText");

        // Populate content
        songEl.innerHTML = unityRichTextToHtml(song.displayName);
        artistEl.innerHTML = unityRichTextToHtml(song.displayArtist);

        // Strip HTML from loading phrase for clean display
        if (song.loadingPhrase) {
          phraseEl.textContent = song.loadingPhrase.replace(/<[^>]*>/g, "");
        } else {
          phraseEl.textContent = "";
        }

        // Show overlay
        overlay.classList.remove("fade-out");
        overlay.classList.add("show");

        // Clear any existing timeout
        if (loadingPhraseTimeout) {
          clearTimeout(loadingPhraseTimeout);
        }

        // Hide after calculated duration (ensures overlay is gone before notes appear)
        loadingPhraseTimeout = setTimeout(() => {
          hideLoadingPhraseOverlay();
        }, duration);
      }

      function hideLoadingPhraseOverlay() {
        const overlay = document.getElementById("loadingPhraseOverlay");
        overlay.classList.add("fade-out");
        overlay.classList.remove("show");

        if (loadingPhraseTimeout) {
          clearTimeout(loadingPhraseTimeout);
          loadingPhraseTimeout = null;
        }
      }

      function resetGame() {
        gameState.score = 0;
        gameState.combo = 0;
        gameState.maxCombo = 0;
        gameState.multiplier = 1;
        gameState.perfectCount = 0;
        gameState.goodCount = 0;
        gameState.okCount = 0;
        gameState.missedCount = 0;
        gameState.activeNotes = [];
        gameState.currentLyricIndex = -1;
        gameState.currentLyricGroupKey = null;
        gameState.songCompleted = false; // Reset completion flag when starting new game
        hitEffects = [];
        laneFlashes = {};
        previousCombo = 0; // Reset combo display state

        // Reset combo display visuals
        const comboDisplay = document.getElementById("comboDisplay");
        if (comboDisplay) {
          comboDisplay.classList.remove("visible", "breaking", "bump");
        }

        // Reset video glow tier
        videoGlow.classList.remove(
          "glow-fire",
          "glow-blazing",
          "glow-unstoppable",
          "glow-legendary",
          "glow-godlike",
          "glow-perfection"
        );

        updateUI();
      }

      function gameLoop() {
        if (!gameState.isPlaying || gameState.isPaused) return;

        const currentTime = getCurrentAudioTime();

        // End song early if we've passed the last note by the buffer
        if (
          gameState.endAfterTime &&
          currentTime >= gameState.endAfterTime * 1000
        ) {
          handleSongComplete();
          return;
        }

        // Check for missed notes
        for (const note of gameState.activeNotes) {
          if (note.hit || note.missed) continue;

          const timeDiff = currentTime - note.time;
          if (timeDiff > CONFIG.hitWindow.okay) {
            note.missed = true;
            handleMiss(note);
          }
        }

        // Handle sustained notes - tick scoring and completion detection
        const laneKeys = getLaneKeys();
        for (const note of gameState.activeNotes) {
          // Only process hit sustained notes that aren't complete or released
          const isSustain = note.durationMs > 50;
          if (
            !note.hit ||
            !isSustain ||
            note.sustainCompleted ||
            note.releasedEarly
          )
            continue;

          const sustainEndTime = note.time + note.durationMs;
          const isBeingHeld = pressedKeys.has(laneKeys[note.lane]);

          // Check if sustain has ended
          if (currentTime >= sustainEndTime) {
            note.sustainCompleted = true;
            if (isBeingHeld) {
              // Successfully held to the end - award completion bonus
              handleSustainComplete(note);
            } else if (!note.releasedEarly) {
              // Key was released after the sustain ended (not early release)
              // Award completion if not already awarded
              handleSustainComplete(note);
            }
            // If releasedEarly is true, keyup already handled the penalty
            continue;
          }

          // Award tick points while holding
          if (isBeingHeld) {
            // Initialize lastTickTime if not set
            if (!note.lastTickTime) {
              note.lastTickTime = note.hitTime || note.time;
            }

            // Check if enough time has passed for another tick
            const timeSinceLastTick = currentTime - note.lastTickTime;
            if (timeSinceLastTick >= CONFIG.sustainTickInterval) {
              // Award tick points
              handleSustainTick(note);
              note.lastTickTime = currentTime;
            }
          }
        }

        // Clean up old notes
        gameState.activeNotes = gameState.activeNotes.filter((n) => {
          if (n.missed) {
            const timeSinceHit = currentTime - n.time;
            return timeSinceHit < 500; // Keep for effect display
          }
          if (n.hit) {
            const isSustain = n.durationMs > 50;
            if (isSustain) {
              // Keep sustained notes until they're complete + buffer for visual
              const sustainEndTime = n.time + n.durationMs;
              return currentTime < sustainEndTime + 300;
            } else {
              const timeSinceHit = currentTime - n.time;
              return timeSinceHit < 500; // Keep for effect display
            }
          }
          return true;
        });

        requestAnimationFrame(gameLoop);
      }

      function handleKeyPress(lane) {
        if (!gameState.isPlaying || gameState.isPaused) return;

        const currentTime = getCurrentAudioTime();

        // Find the best note to hit in this lane
        let bestNote = null;
        let bestDiff = Infinity;

        for (const note of gameState.activeNotes) {
          if (note.lane !== lane || note.hit || note.missed) continue;

          const timeDiff = Math.abs(currentTime - note.time);
          if (timeDiff < bestDiff && timeDiff <= CONFIG.hitWindow.okay) {
            bestDiff = timeDiff;
            bestNote = note;
          }
        }

        if (bestNote) {
          handleHit(bestNote, bestDiff);
        } else {
          // Overstrum penalty - pressed a lane with no note
          handleOverstrum(lane);
        }
      }

      function handleHit(note, timeDiff) {
        note.hit = true;
        note.hitTime = getCurrentAudioTime(); // Track when the note was hit for sustained notes

        let rating, points, colorRgb;

        if (timeDiff <= CONFIG.hitWindow.perfect) {
          rating = "PERFECT";
          points = CONFIG.points.perfect;
          colorRgb = "255, 255, 255"; // Bright white for perfect
          gameState.perfectCount++;
        } else if (timeDiff <= CONFIG.hitWindow.good) {
          rating = "GOOD";
          points = CONFIG.points.good;
          colorRgb = "34, 255, 94"; // Bright green for good
          gameState.goodCount++;
        } else {
          rating = "OK";
          points = CONFIG.points.okay;
          colorRgb = "255, 200, 50"; // Bright yellow for OK
          gameState.okCount++;
        }

        gameState.combo++;
        if (gameState.combo > gameState.maxCombo) {
          gameState.maxCombo = gameState.combo;
        }

        // Update multiplier
        if (gameState.combo >= 40) gameState.multiplier = 4;
        else if (gameState.combo >= 20) gameState.multiplier = 3;
        else if (gameState.combo >= 10) gameState.multiplier = 2;
        else gameState.multiplier = 1;

        // Apply lane difficulty multiplier (more lanes = higher score)
        const laneMultiplier = getLaneDifficultyMultiplier();
        gameState.score += Math.round(
          points * gameState.multiplier * laneMultiplier
        );

        // Adjust song volume on hit
        onNoteHit(rating);

        // Update video effects based on multiplier
        updateVideoIntensity();

        // Pulse video glow on hit
        pulseVideoGlow();

        // Add hit effect with flash
        hitEffects.push({
          lane: note.lane,
          time: Date.now(),
          text: rating,
          color: colorRgb,
          type: "hit",
        });

        // Add lane flash effect
        laneFlashes[note.lane] = { time: Date.now(), color: colorRgb };

        updateUI();
      }

      function handleMiss(note) {
        gameState.missedCount++;
        gameState.combo = 0;
        gameState.multiplier = 1;

        // Lower song volume on miss
        onNoteMiss();

        // Reset video intensity on miss
        updateVideoIntensity();

        hitEffects.push({
          lane: note.lane,
          time: Date.now(),
          text: "MISS",
          color: "239, 68, 68",
          type: "miss",
        });

        // Add red flash for miss
        laneFlashes[note.lane] = { time: Date.now(), color: "255, 50, 50" };

        updateUI();
      }

      function handleSustainTick(note) {
        // Award tick points for holding sustained note
        const laneMultiplier = getLaneDifficultyMultiplier();
        gameState.score += Math.round(
          CONFIG.points.sustainTick * gameState.multiplier * laneMultiplier
        );

        // Small visual feedback for tick (subtle effect)
        hitEffects.push({
          lane: note.lane,
          time: Date.now(),
          text: "+" + CONFIG.points.sustainTick,
          color: "100, 200, 255", // Light blue for sustain ticks
          type: "sustainTick",
        });

        updateUI();
      }

      function handleSustainComplete(note) {
        // Prevent duplicate completion rewards
        if (note.completionAwarded) return;
        note.completionAwarded = true;

        // Award completion bonus for holding to the end
        const laneMultiplier = getLaneDifficultyMultiplier();
        gameState.score += Math.round(
          CONFIG.points.sustainComplete * gameState.multiplier * laneMultiplier
        );

        // Visual feedback for completion
        hitEffects.push({
          lane: note.lane,
          time: Date.now(),
          text: "HELD!",
          color: "255, 215, 0", // Gold for completion
          type: "sustainComplete",
        });

        // Add golden flash effect
        laneFlashes[note.lane] = { time: Date.now(), color: "255, 215, 0" };

        updateUI();
      }

      function handleSustainRelease(note) {
        // Handle early release of sustained note
        note.releasedEarly = true;

        // Break combo
        gameState.combo = 0;
        gameState.multiplier = 1;

        // Lower song volume on early release (similar to miss)
        onNoteMiss();

        // Reset video intensity
        updateVideoIntensity();

        // Visual feedback for early release
        hitEffects.push({
          lane: note.lane,
          time: Date.now(),
          text: "RELEASED",
          color: "255, 150, 50", // Orange for early release
          type: "sustainRelease",
        });

        // Add orange flash for early release
        laneFlashes[note.lane] = { time: Date.now(), color: "255, 150, 50" };

        updateUI();
      }

      function handleOverstrum(lane) {
        // Only penalize if there's a combo to break
        if (gameState.combo === 0) return;

        gameState.combo = 0;
        gameState.multiplier = 1;

        // Reset video intensity on overstrum
        updateVideoIntensity();

        // Add red flash for overstrum (no text, just visual feedback)
        laneFlashes[lane] = { time: Date.now(), color: "255, 50, 50" };

        updateUI();
      }

      let previousCombo = 0;
      let comboAnimationTimeout = null;

      function updateUI() {
        document.getElementById("score").textContent =
          gameState.score.toLocaleString();
        document.getElementById("combo").textContent =
          gameState.combo > 0 ? `${gameState.combo} COMBO` : "";
        document.getElementById("multiplier").textContent =
          gameState.multiplier > 1 ? `${gameState.multiplier}x` : "";
        document.getElementById("perfectCount").textContent =
          gameState.perfectCount;
        document.getElementById("goodCount").textContent = gameState.goodCount;
        document.getElementById("okCount").textContent = gameState.okCount;
        document.getElementById("missedCount").textContent =
          gameState.missedCount;
        document.getElementById("maxComboCount").textContent =
          gameState.maxCombo;

        // Update new combo display
        updateComboDisplay();
      }

      function updateComboDisplay() {
        const comboDisplay = document.getElementById("comboDisplay");
        const comboNumber = document.getElementById("comboNumber");
        const comboMultiplier = document.getElementById("comboMultiplier");
        const combo = gameState.combo;

        // Handle combo break
        if (previousCombo > 5 && combo === 0) {
          comboDisplay.classList.add("breaking");
          setTimeout(() => {
            comboDisplay.classList.remove("breaking", "visible");
          }, 400);
          previousCombo = combo;
          return;
        }

        // Hide if no combo
        if (combo === 0) {
          comboDisplay.classList.remove("visible");
          previousCombo = combo;
          return;
        }

        // Show combo display (only show after 3 combo to avoid clutter)
        if (combo >= 3) {
          comboDisplay.classList.add("visible");
          comboDisplay.classList.remove("breaking");
        }

        // Update the number
        comboNumber.textContent = combo;

        // Update multiplier badge
        if (gameState.multiplier > 1) {
          comboMultiplier.textContent = gameState.multiplier + "x";
          comboMultiplier.style.display = "block";
        } else {
          comboMultiplier.style.display = "none";
        }

        // Add bump animation on combo increase
        if (combo > previousCombo && combo >= 3) {
          comboDisplay.classList.remove("bump");
          void comboDisplay.offsetWidth; // Force reflow
          comboDisplay.classList.add("bump");

          // Spawn particles on milestone combos
          if (
            combo % 10 === 0 ||
            combo === 25 ||
            combo === 50 ||
            combo === 75 ||
            combo === 100 ||
            combo === 150 ||
            combo === 200
          ) {
            spawnComboParticles(combo);
          }

          // Trigger milestone effects for specific combos
          if ([25, 50, 75, 100, 150, 200].includes(combo)) {
            triggerMilestoneEffect(combo);
          }
        }

        previousCombo = combo;
      }

      function spawnComboParticles(combo) {
        const container = document.getElementById("comboParticles");
        const particleCount = Math.min(combo / 5, 20); // More particles for higher combos

        // Default combo particle colors
        const colors = ["#4ade80", "#22c55e", "#86efac"];

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "combo-particle";

          // Random position in center
          const startX = 150 + (Math.random() - 0.5) * 80;
          const startY = 75;
          particle.style.left = startX + "px";
          particle.style.top = startY + "px";

          // Random direction and distance
          const angle = Math.random() * Math.PI * 2;
          const distance = 60 + Math.random() * 100;
          const dx = Math.cos(angle) * distance;
          const dy = Math.sin(angle) * distance - 50; // Bias upward

          particle.style.setProperty("--dx", dx + "px");
          particle.style.setProperty("--dy", dy + "px");

          // Random color from palette
          particle.style.backgroundColor =
            colors[Math.floor(Math.random() * colors.length)];
          particle.style.boxShadow = `0 0 10px ${particle.style.backgroundColor}`;

          // Random size
          const size = 4 + Math.random() * 8;
          particle.style.width = size + "px";
          particle.style.height = size + "px";

          container.appendChild(particle);

          // Remove after animation
          setTimeout(() => particle.remove(), 800);
        }
      }

      function triggerMilestoneEffect(combo) {
        const gameArea = document.getElementById("gameArea");
        const milestoneFlash = document.getElementById("milestoneFlash");
        const milestoneText = document.getElementById("milestoneText");

        // Define milestones and their effects
        const milestones = {
          25: { text: "ON FIRE! üî•", color: "#4ade80", shake: true },
          50: {
            text: "BLAZING! üî•üî•",
            color: "#60a5fa",
            shake: true,
            gold: false,
          },
          75: {
            text: "UNSTOPPABLE! ‚ö°",
            color: "#fb923c",
            shake: true,
            gold: false,
          },
          100: {
            text: "üíÄ LEGENDARY! üíÄ",
            color: "#ffd700",
            shake: true,
            gold: true,
          },
          150: {
            text: "üåü GODLIKE! üåü",
            color: "#fff",
            shake: true,
            gold: true,
          },
          200: {
            text: "üëë PERFECTION üëë",
            color: "#f472b6",
            shake: true,
            gold: true,
          },
        };

        const milestone = milestones[combo];
        if (!milestone) return;

        // Screen shake
        if (milestone.shake) {
          gameArea.classList.remove("screen-shake");
          void gameArea.offsetWidth;
          gameArea.classList.add("screen-shake");
          setTimeout(() => gameArea.classList.remove("screen-shake"), 300);
        }

        // Flash effect
        milestoneFlash.classList.remove("flash", "flash-gold");
        void milestoneFlash.offsetWidth;
        milestoneFlash.classList.add(milestone.gold ? "flash-gold" : "flash");
        setTimeout(
          () => milestoneFlash.classList.remove("flash", "flash-gold"),
          600
        );

        // Text popup
        milestoneText.textContent = milestone.text;
        milestoneText.style.color = milestone.color;
        milestoneText.style.textShadow = `0 0 30px ${milestone.color}, 0 0 60px ${milestone.color}`;
        milestoneText.classList.remove("show");
        void milestoneText.offsetWidth;
        milestoneText.classList.add("show");
        setTimeout(() => milestoneText.classList.remove("show"), 1200);
      }

      function drawStaticScreen() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawHighway();
        drawHitLine();
      }

      // ============================================
      // EVENT HANDLERS
      // ============================================

      window.addEventListener("keydown", (e) => {
        const key = e.key.toLowerCase();
        const laneKeys = getLaneKeys();
        if (laneKeys.includes(key) && !pressedKeys.has(key)) {
          pressedKeys.add(key);
          const lane = laneKeys.indexOf(key);
          handleKeyPress(lane);
        }

        // Escape to stop (with save prompt if there's a score)
        if (e.key === "Escape" && (gameState.isPlaying || gameState.isPaused)) {
          if (gameState.score > 0) {
            showSaveScorePrompt("stop");
          } else {
            stopGame();
          }
        }

        // Space to play/pause (but not when typing in search)
        if (
          e.key === " " &&
          gameState.currentSong &&
          document.activeElement.tagName !== "INPUT"
        ) {
          e.preventDefault();
          togglePlayPause();
        }

        // P to pause/resume (but not when typing in search)
        if (
          e.key.toLowerCase() === "p" &&
          gameState.isPlaying &&
          document.activeElement.tagName !== "INPUT"
        ) {
          if (gameState.isPaused) {
            resumeGame();
          } else {
            pauseGame();
          }
        }
      });

      window.addEventListener("keyup", (e) => {
        const key = e.key.toLowerCase();
        pressedKeys.delete(key);

        // Check for early release of sustained notes
        if (gameState.isPlaying && !gameState.isPaused) {
          const laneKeys = getLaneKeys();
          const lane = laneKeys.indexOf(key);

          if (lane !== -1) {
            const currentTime = getCurrentAudioTime();

            // Find any sustained notes in this lane that are being held
            for (const note of gameState.activeNotes) {
              const isSustain = note.durationMs > 50;
              if (
                !isSustain ||
                !note.hit ||
                note.sustainCompleted ||
                note.releasedEarly
              )
                continue;
              if (note.lane !== lane) continue;

              const sustainEndTime = note.time + note.durationMs;
              const timeUntilEnd = sustainEndTime - currentTime;

              // INTENTIONAL ASYMMETRIC GRACE PERIOD (not a bug):
              // - timeUntilEnd > 0 means before end, <= 0 means after end
              // - We allow releases up to gracePeriod ms BEFORE the end (forgiving early releases)
              // - We allow ALL releases AFTER the end (never punish holding too long)
              // - This is why we use `<=` without Math.abs() - it's asymmetric by design
              if (timeUntilEnd <= CONFIG.sustainGracePeriod) {
                // Within grace period or past the end - count as successfully held
                note.sustainCompleted = true;
                handleSustainComplete(note);
              } else {
                // Released too early (more than gracePeriod ms before the end)
                handleSustainRelease(note);
              }
            }
          }
        }
      });

      window.addEventListener("resize", () => {
        resizeCanvas();
        if (!gameState.isPlaying) {
          drawStaticScreen();
        }
      });

      // Instrument selection
      document.querySelectorAll(".instrument-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (btn.disabled || gameState.isPlaying) return;
          document
            .querySelectorAll(".instrument-btn")
            .forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          gameState.instrument = btn.dataset.instrument;

          // Track instrument selection
          trackEvent("select_instrument", {
            instrument: btn.dataset.instrument,
          });

          // Update difficulty buttons for new instrument
          if (gameState.currentSong) {
            updateDifficultyButtons(gameState.currentSong);
          }
        });
      });

      // Difficulty selection
      document.querySelectorAll(".diff-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (btn.disabled || gameState.isPlaying) return;
          document
            .querySelectorAll(".diff-btn")
            .forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          gameState.difficulty = btn.dataset.diff;

          // Track difficulty selection
          trackEvent("select_difficulty", {
            difficulty: btn.dataset.diff,
          });
        });
      });

      // Lane count selection
      document.querySelectorAll(".lane-btn").forEach((btn) => {
        btn.addEventListener("click", () => {
          if (gameState.isPlaying || btn.disabled) return;
          document
            .querySelectorAll(".lane-btn")
            .forEach((b) => b.classList.remove("selected"));
          btn.classList.add("selected");
          activeLaneCount = parseInt(btn.dataset.lanes, 10);
          gameState.laneCount = activeLaneCount;

          // Track lane count selection
          trackEvent("select_lanes", {
            lane_count: activeLaneCount,
          });

          updateGameAreaMinWidth();
          // Redraw static screen to show new lane count
          if (!gameState.isPlaying) {
            drawStaticScreen();
          }
        });
      });

      // Play button
      document.getElementById("playBtn").addEventListener("click", () => {
        togglePlayPause();
      });

      // Mini play button
      document.getElementById("miniPlayBtn").addEventListener("click", () => {
        togglePlayPause();
      });

      // Stop button
      document.getElementById("stopBtn").addEventListener("click", () => {
        // If there's a score to save, prompt first
        if (
          (gameState.isPlaying || gameState.isPaused) &&
          gameState.score > 0
        ) {
          showSaveScorePrompt("stop");
        } else {
          stopGame();
        }
      });

      // Restart button
      document.getElementById("restartBtn").addEventListener("click", () => {
        restartGame();
      });

      // Song switch modal buttons
      document
        .getElementById("modalCancelBtn")
        .addEventListener("click", () => {
          hideSwitchSongModal();
        });

      document
        .getElementById("modalConfirmBtn")
        .addEventListener("click", () => {
          confirmSongSwitch();
        });

      // Close modal on background click
      document
        .getElementById("switchSongModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "switchSongModal") {
            hideSwitchSongModal();
          }
        });

      // Close modal on Escape key
      document.addEventListener("keydown", (e) => {
        if (
          e.key === "Escape" &&
          document.getElementById("switchSongModal").classList.contains("show")
        ) {
          hideSwitchSongModal();
          e.stopPropagation();
        }
        // Also handle Escape for name entry modal
        if (
          e.key === "Escape" &&
          document.getElementById("nameEntryModal").classList.contains("show")
        ) {
          hideNameEntryModalAndContinue();
          e.stopPropagation();
        }
        // Handle Escape for save score prompt
        if (
          e.key === "Escape" &&
          document.getElementById("saveScorePrompt").classList.contains("show")
        ) {
          handlePromptNoSave();
          e.stopPropagation();
        }
      });

      // Name entry modal buttons
      document.getElementById("skipScoreBtn").addEventListener("click", () => {
        hideNameEntryModalAndContinue();
      });

      document
        .getElementById("submitScoreBtn")
        .addEventListener("click", async () => {
          const nameInput = document.getElementById("playerNameInput");
          const playerName = nameInput.value.trim();

          if (playerName) {
            await submitScore(playerName);
          }
          hideNameEntryModalAndContinue();
        });

      // Submit on Enter key in name input
      document
        .getElementById("playerNameInput")
        .addEventListener("keydown", async (e) => {
          if (e.key === "Enter") {
            const playerName = e.target.value.trim();
            if (playerName) {
              await submitScore(playerName);
            }
            hideNameEntryModalAndContinue();
          }
        });

      // Close name entry modal on background click
      document
        .getElementById("nameEntryModal")
        .addEventListener("click", (e) => {
          if (e.target.id === "nameEntryModal") {
            hideNameEntryModalAndContinue();
          }
        });

      // Save score prompt buttons
      document.getElementById("promptSaveBtn").addEventListener("click", () => {
        handlePromptSave();
      });

      document
        .getElementById("promptNoSaveBtn")
        .addEventListener("click", () => {
          handlePromptNoSave();
        });

      // Close save prompt on background click
      document
        .getElementById("saveScorePrompt")
        .addEventListener("click", (e) => {
          if (e.target.id === "saveScorePrompt") {
            handlePromptNoSave();
          }
        });

      // High scores subtitle click - toggle between song and all scores
      document
        .getElementById("highScoreSubtitle")
        .addEventListener("click", () => {
          toggleHighScoresView();
        });

      // Collapse/expand now playing section
      document
        .getElementById("nowPlayingHeader")
        .addEventListener("click", () => {
          const nowPlaying = document.getElementById("nowPlaying");
          nowPlaying.classList.toggle("collapsed");
        });

      // Search functionality
      const searchInput = document.getElementById("searchInput");
      const clearSearchBtn = document.getElementById("clearSearch");

      searchInput.addEventListener("input", (e) => {
        const query = e.target.value;
        filterSongs(query);

        // Show/hide clear button
        if (query.length > 0) {
          clearSearchBtn.classList.add("visible");
        } else {
          clearSearchBtn.classList.remove("visible");
        }

        // Update clear filters visibility
        updateClearFiltersVisibility();
      });

      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        filterSongs("");
        clearSearchBtn.classList.remove("visible");
        searchInput.focus();
        updateClearFiltersVisibility();
      });

      // Allow Escape to clear search when focused
      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          if (searchInput.value) {
            searchInput.value = "";
            filterSongs("");
            clearSearchBtn.classList.remove("visible");
            e.stopPropagation();
          } else {
            searchInput.blur();
          }
        }
      });

      // Drag and drop support
      const dropZone = document.getElementById("dropZone");

      document.body.addEventListener("dragover", (e) => {
        e.preventDefault();
        dropZone.classList.add("active");
      });

      document.body.addEventListener("dragleave", (e) => {
        if (e.target === dropZone) {
          dropZone.classList.remove("active");
        }
      });

      document.body.addEventListener("drop", async (e) => {
        e.preventDefault();
        dropZone.classList.remove("active");
        showLoading();

        const items = e.dataTransfer.items;
        for (const item of items) {
          if (item.kind === "file") {
            const entry = item.webkitGetAsEntry();
            if (entry) {
              if (entry.isDirectory) {
                await processDroppedDirectory(entry);
              } else if (entry.isFile) {
                // Handle individual files - collect siblings from same drop
                // (files dropped together likely belong to the same song)
                await handleDroppedFiles(e.dataTransfer.files);
                break; // Only process files once
              }
            }
          }
        }

        hideLoading();
      });

      // Handle multiple files dropped together (likely a song's files)
      async function handleDroppedFiles(fileList) {
        const files = {};
        for (const file of fileList) {
          files[file.name] = file;
        }
        await loadSongFromFiles(files, "Dropped Song");
      }

      // Process a dropped directory - could be a song folder or a collection
      async function processDroppedDirectory(dirEntry) {
        const files = {};
        const subdirs = [];

        const readAllEntries = async (entry) => {
          return new Promise((resolve) => {
            const reader = entry.createReader();
            const allEntries = [];

            const readBatch = () => {
              reader.readEntries((entries) => {
                if (entries.length === 0) {
                  resolve(allEntries);
                } else {
                  allEntries.push(...entries);
                  readBatch();
                }
              });
            };
            readBatch();
          });
        };

        const readFile = (fileEntry) =>
          new Promise((resolve) => {
            fileEntry.file(resolve);
          });

        const entries = await readAllEntries(dirEntry);

        for (const entry of entries) {
          if (entry.isFile) {
            const file = await readFile(entry);
            files[entry.name] = file;
          } else if (entry.isDirectory) {
            subdirs.push(entry);
          }
        }

        // Check if this folder IS a song (has chart file)
        if (files["notes.chart"] || files["notes.mid"]) {
          await loadSongFromFiles(files, dirEntry.name);
        } else if (subdirs.length > 0) {
          // This is a collection folder - recursively process subdirectories
          for (const subdir of subdirs) {
            await processDroppedDirectory(subdir);
          }
        }
      }

      // Shared function to load a song from a files object
      async function loadSongFromFiles(files, folderName) {
        let chart = null;
        let chartHash = null;

        // Try notes.chart first, then notes.mid
        if (files["notes.chart"]) {
          const chartText = await files["notes.chart"].text();
          chart = new ChartParser(chartText);
          // Compute checksum of the chart file for unique identification
          chartHash = await computeChartHash(chartText);
        } else if (files["notes.mid"]) {
          const midiBuffer = await files["notes.mid"].arrayBuffer();
          chart = new MidiParser(midiBuffer);
          // Compute checksum of the MIDI file using ArrayBuffer directly
          chartHash = await computeChartHashFromBuffer(midiBuffer);
        }

        // Find audio file
        const audioFile =
          files["song.opus"] ||
          files["song.ogg"] ||
          files["song.mp3"] ||
          files["guitar.opus"] ||
          files["guitar.ogg"] ||
          files["guitar.mp3"];

        if (chart && audioFile) {
          let iniData = {};
          if (files["song.ini"]) {
            const iniText = await files["song.ini"].text();
            iniData = parseIni(iniText);
          }

          const albumFile =
            files["album.png"] ||
            files["album.jpg"] ||
            files["album.jpeg"] ||
            files["album.webp"] ||
            files["album.gif"];
          const backgroundFile =
            files["background.png"] ||
            files["background.jpg"] ||
            files["background.jpeg"] ||
            files["background.webp"] ||
            files["background.gif"];
          const videoFile =
            files["video.webm"] || files["video.mp4"] || files["video.ogv"];

          const song = {
            path: folderName,
            name:
              chart.songData?.Name || stripRichText(iniData.name) || folderName,
            artist:
              chart.songData?.Artist ||
              stripRichText(iniData.artist) ||
              "Unknown Artist",
            album: chart.songData?.Album || stripRichText(iniData.album) || "",
            charter:
              chart.songData?.Charter || stripRichText(iniData.charter) || "",
            displayName: hasRichText(iniData.name)
              ? iniData.name
              : chart.songData?.Name ||
                stripRichText(iniData.name) ||
                folderName,
            displayArtist: hasRichText(iniData.artist)
              ? iniData.artist
              : chart.songData?.Artist ||
                stripRichText(iniData.artist) ||
                "Unknown Artist",
            albumArtUrl: albumFile ? URL.createObjectURL(albumFile) : "",
            audioUrl: URL.createObjectURL(audioFile),
            backgroundUrl: backgroundFile
              ? URL.createObjectURL(backgroundFile)
              : null,
            videoUrl: videoFile ? URL.createObjectURL(videoFile) : null,
            chartData: chart,
            chartHash: chartHash,
            availableInstruments: chart.getAvailableInstruments(),
            availableTracks: chart.getAvailableTracks(),
            // Quick win fields from song.ini
            songLength: parseInt(iniData.song_length) || null,
            difficulty: parseInt(iniData.diff_guitar) ?? null,
            previewStartTime: parseInt(iniData.preview_start_time) || 0,
            videoStartTime: parseInt(iniData.video_start_time) || 0,
            loadingPhrase: iniData.loading_phrase || null,
            genre: iniData.genre || null,
            year: iniData.year || null,
            // Per-instrument difficulties
            diffGuitar: parseInt(iniData.diff_guitar) ?? -1,
            diffBass: parseInt(iniData.diff_bass) ?? -1,
            diffDrums: parseInt(iniData.diff_drums) ?? -1,
            diffKeys: parseInt(iniData.diff_keys) ?? -1,
          };

          addSongToList(song);
        }
      }

      // ============================================
      // FILE SYSTEM ACCESS API - FOLDER PICKER
      // ============================================

      async function openSongsFolder() {
        if (!("showDirectoryPicker" in window)) {
          alert(
            "Your browser does not support folder selection. Try Chrome or Edge, or drag-and-drop folders instead."
          );
          return;
        }

        try {
          const dirHandle = await window.showDirectoryPicker({ mode: "read" });
          showLoading();

          // Check if selected folder itself is a song folder
          const isSong = await checkIfSongFolderHandle(dirHandle);
          if (isSong) {
            await loadSongFromDirectoryHandle(dirHandle);
          } else {
            // It's a collection - scan for songs inside
            await scanDirectory(dirHandle);
          }

          hideLoading();
        } catch (e) {
          if (e.name !== "AbortError") {
            console.error("Failed to open folder:", e);
            alert("Failed to open folder: " + e.message);
          }
          hideLoading();
        }
      }

      async function scanDirectory(dirHandle) {
        for await (const entry of dirHandle.values()) {
          if (entry.kind === "directory") {
            const subDir = await dirHandle.getDirectoryHandle(entry.name);
            const isSongFolder = await checkIfSongFolderHandle(subDir);

            if (isSongFolder) {
              await loadSongFromDirectoryHandle(subDir);
            } else {
              // Recurse deeper into subdirectories
              await scanDirectory(subDir);
            }
          }
        }
      }

      async function checkIfSongFolderHandle(dirHandle) {
        // A song folder contains notes.chart or notes.mid
        for await (const entry of dirHandle.values()) {
          if (entry.kind === "file") {
            if (entry.name === "notes.chart" || entry.name === "notes.mid") {
              return true;
            }
          }
        }
        return false;
      }

      async function loadSongFromDirectoryHandle(dirHandle) {
        const files = {};

        // Read all files in the directory
        for await (const entry of dirHandle.values()) {
          if (entry.kind === "file") {
            const file = await entry.getFile();
            files[entry.name] = file;
          }
        }

        await loadSongFromFiles(files, dirHandle.name);
      }

      function showLoading() {
        document.getElementById("loading").classList.remove("hidden");
      }

      function hideLoading() {
        document.getElementById("loading").classList.add("hidden");
      }

      // ============================================
      // INITIALIZATION
      // ============================================

      async function init() {
        resizeCanvas();
        updateGameAreaMinWidth();
        // Wait for fonts to load before drawing to ensure consistent rendering
        await document.fonts.ready;
        drawStaticScreen();
        initInputDeviceSelector();
        checkExistingGamepads();
        updateSongCount();
        updateLeftPanelVisibility(); // Set initial panel visibility
        hideLoading();
      }

      init();
    </script>
  </body>
</html>
